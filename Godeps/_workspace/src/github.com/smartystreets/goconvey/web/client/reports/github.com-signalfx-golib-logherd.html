
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/signalfx/golib/logherd/logherd.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package logherd

import (
        "path/filepath"
        "runtime"

        "io"

        "sync"

        "github.com/Sirupsen/logrus"
)

//  A group of walrus is a herd .... we manage a group of logrus .........
//  get it?
//  the joke?
//  because a bunch of walrus .... logrus.....
//  got it now?
type herdManager struct {
        loggers map[loggerKey]*logInstance
        lock    sync.Mutex
}

type loggerKey struct {
        filename string
}

type logInstance struct {
        innerLogger *logrus.Logger
}

// NoopWriter makes all Write() functions return as fully written without actually doing anything
type NoopWriter struct{}

func (d *NoopWriter) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        return len(p), nil
}</span>

var _ io.Writer = &amp;NoopWriter{}

type wrappedWritter struct {
        io.Writer
        setBackTo io.Writer
}

var _ io.Writer = &amp;wrappedWritter{}

// LogrusDimensionAdder is a hook that adds the dimension Key-&gt;Value to the event's data.
type LogrusDimensionAdder struct {
        Key, Value string
        FireLevels []logrus.Level
}

// Fire adds [Key] = [Value] to the event
func (l *LogrusDimensionAdder) Fire(e *logrus.Entry) error <span class="cov8" title="1">{
        if _, exists := e.Data[l.Key]; !exists </span><span class="cov8" title="1">{
                e.Data[l.Key] = l.Value
        }</span>
        <span class="cov8" title="1">return nil</span>
}

var allLogrusLevels = []logrus.Level{
        logrus.PanicLevel,
        logrus.FatalLevel,
        logrus.ErrorLevel,
        logrus.WarnLevel,
        logrus.InfoLevel,
        logrus.DebugLevel,
}

// Levels returns the field FireLevels
func (l *LogrusDimensionAdder) Levels() []logrus.Level <span class="cov8" title="1">{
        return l.FireLevels
}</span>

var _ logrus.Hook = &amp;LogrusDimensionAdder{}

var instance = &amp;herdManager{
        loggers: make(map[loggerKey]*logInstance),
}

// SetLevel will set the level of the default logrus logger and all loggers registered to sfxlog
func SetLevel(level logrus.Level) logrus.Level <span class="cov8" title="1">{
        instance.lock.Lock()
        defer instance.lock.Unlock()
        ret := logrus.GetLevel()
        logrus.SetLevel(level)
        for _, v := range instance.loggers </span><span class="cov8" title="1">{
                v.innerLogger.Level = level
        }</span>
        <span class="cov8" title="1">return ret</span>
}

// SetOutput sets the output writer of all loggers and return the previous output.  You can stub
// the output during a function with something like
// func TestBob() {
//   defer sfxlog.SetOutput(sfxlog.SetOutput(&amp;sfxlog.NoopWriter{}))
// }
func SetOutput(out io.Writer) io.Writer <span class="cov8" title="1">{
        // When used as the example above, on the second call you want to wait as long as possible
        // before setting the writer back, so Gosched
        runtime.Gosched()
        instance.lock.Lock()
        defer instance.lock.Unlock()
        logrus.SetOutput(out)
        ret := logrus.StandardLogger().Out
        for _, v := range instance.loggers </span><span class="cov8" title="1">{
                v.innerLogger.Out = out
        }</span>
        <span class="cov8" title="1">return ret</span>
}

// SilenceOutput for all loggers while restoring each when done.  Intended to be used like:
// func Bob() {
//    defer sfxlog.SilenceOutput()()
//    ....
// }
func SilenceOutput() func() <span class="cov8" title="1">{
        instance.lock.Lock()
        defer instance.lock.Unlock()

        silence := &amp;NoopWriter{}
        logrus.SetOutput(&amp;wrappedWritter{Writer: silence, setBackTo: logrus.StandardLogger().Out})
        for _, v := range instance.loggers </span><span class="cov8" title="1">{
                v.innerLogger.Out = &amp;wrappedWritter{Writer: silence, setBackTo: v.innerLogger.Out}
        }</span>
        <span class="cov8" title="1">ret := func() </span><span class="cov8" title="1">{
                // It's usually best to yield here so we can end any Close() goroutines and silence their
                // logging too
                runtime.Gosched()
                if item, ok := logrus.StandardLogger().Out.(*wrappedWritter); ok </span><span class="cov8" title="1">{
                        logrus.SetOutput(item.setBackTo)
                }</span>
                <span class="cov8" title="1">for _, v := range instance.loggers </span><span class="cov8" title="1">{
                        if item, ok := v.innerLogger.Out.(*wrappedWritter); ok </span><span class="cov8" title="1">{
                                v.innerLogger.Out = item.setBackTo
                        }</span>
                }
        }
        <span class="cov8" title="1">return ret</span>
}

// SetFormatter setes the output formatter for all loggers
func SetFormatter(formatter logrus.Formatter) logrus.Formatter <span class="cov8" title="1">{
        instance.lock.Lock()
        defer instance.lock.Unlock()
        ret := logrus.StandardLogger().Formatter
        logrus.SetFormatter(formatter)
        for _, v := range instance.loggers </span><span class="cov8" title="1">{
                v.innerLogger.Formatter = formatter
        }</span>
        <span class="cov8" title="1">return ret</span>
}

var runtimeCaller = runtime.Caller

// New returns a logger that will add a param called "file" that is the filename of the caller
func New() *logrus.Logger <span class="cov8" title="1">{
        instance.lock.Lock()
        defer instance.lock.Unlock()
        _, file, _, ok := runtimeCaller(1)
        if !ok </span><span class="cov8" title="1">{
                file = "unknown"
        }</span>
        <span class="cov8" title="1">key := loggerKey{
                filename: filepath.Base(file),
        }
        if current, exists := instance.loggers[key]; exists </span><span class="cov8" title="1">{
                logrus.WithField("file", file).Warn("Ambiguous logger")
                return current.innerLogger
        }</span>

        <span class="cov8" title="1">ret := logrus.New()
        ret.Level = logrus.GetLevel()
        inst := &amp;logInstance{
                innerLogger: ret,
        }
        instance.loggers[key] = inst
        ret.Out = logrus.StandardLogger().Out
        ret.Formatter = logrus.StandardLogger().Formatter
        ret.Hooks.Add(&amp;LogrusDimensionAdder{
                Key:        "file",
                Value:      key.filename,
                FireLevels: allLogrusLevels,
        })
        return ret</span>
}

// Debug to logger a key/value pair and message.  Intended to save the mem alloc that WithField creates
func Debug(l *logrus.Logger, key string, val interface{}, msg string) <span class="cov8" title="1">{
        if l.Level &gt;= logrus.DebugLevel </span><span class="cov8" title="1">{
                if key != "" </span><span class="cov8" title="1">{
                        l.WithField(key, val).Debug(msg)
                }</span><span class="cov8" title="1"> else {
                        l.Debug(msg)
                }</span>
        }
}

// Debug2 to logger 2 key/value pairs and message.  Intended to save the mem alloc that WithField creates
func Debug2(l *logrus.Logger, key string, val interface{}, key2 string, val2 interface{}, msg string) <span class="cov8" title="1">{
        if l.Level &gt;= logrus.DebugLevel </span><span class="cov8" title="1">{
                if key != "" </span><span class="cov8" title="1">{
                        l.WithField(key, val).WithField(key2, val2).Debug(msg)
                }</span><span class="cov8" title="1"> else {
                        l.Debug(msg)
                }</span>
        }
}

// Debug3 to logger 3 key/value pairs and message.  Intended to save the mem alloc that WithField creates
func Debug3(l *logrus.Logger, key string, val interface{}, key2 string, val2 interface{}, key3 string, val3 interface{}, msg string) <span class="cov8" title="1">{
        if l.Level &gt;= logrus.DebugLevel </span><span class="cov8" title="1">{
                if key != "" </span><span class="cov8" title="1">{
                        l.WithField(key, val).WithField(key2, val2).WithField(key3, val3).Debug(msg)
                }</span><span class="cov8" title="1"> else {
                        l.Debug(msg)
                }</span>
        }
}

// Debug4 to logger 4 key/value pairs and message.  Intended to save the mem alloc that WithField creates
func Debug4(l *logrus.Logger, key string, val interface{}, key2 string, val2 interface{}, key3 string, val3 interface{}, key4 string, val4 interface{}, msg string) <span class="cov8" title="1">{
        if l.Level &gt;= logrus.DebugLevel </span><span class="cov8" title="1">{
                if key != "" </span><span class="cov8" title="1">{
                        l.WithField(key, val).WithField(key2, val2).WithField(key3, val3).WithField(key4, val4).Debug(msg)
                }</span><span class="cov8" title="1"> else {
                        l.Debug(msg)
                }</span>
        }
}

// Debugf to logger a logrus.Fields and message.  Intended to save the mem alloc that WithField creates
func Debugf(l *logrus.Logger, fields logrus.Fields, msg string) <span class="cov8" title="1">{
        if l.Level &gt;= logrus.DebugLevel </span><span class="cov8" title="1">{
                l.WithFields(fields).Debug(msg)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
