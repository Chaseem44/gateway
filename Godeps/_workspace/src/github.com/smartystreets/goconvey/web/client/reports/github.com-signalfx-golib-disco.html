
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/signalfx/golib/disco/disco.go (100.0%)</option>
				
				<option value="file1">github.com/signalfx/golib/disco/thrift.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package disco

import (
        "crypto/rand"
        "io"

        "encoding/json"
        "fmt"
        "sync/atomic"
        "time"

        "strings"
        "sync"

        "bytes"
        "encoding/binary"
        "sort"

        "errors"

        "github.com/Sirupsen/logrus"
        "github.com/samuel/go-zookeeper/zk"
        "github.com/signalfx/golib/logherd"
        "github.com/signalfx/golib/zkplus"
)

var log *logrus.Logger

func init() <span class="cov8" title="1">{
        log = logherd.New()
}</span>

// ServiceInstance defines a remote service and is similar to
// https://curator.apache.org/apidocs/org/apache/curator/x/discovery/ServiceInstanceBuilder.html
type ServiceInstance struct {
        ID                  string      `json:"id"`
        Name                string      `json:"name"`
        Payload             interface{} `json:"payload,omitempty"`
        Address             string      `json:"address"`
        Port                uint16      `json:"port"`
        RegistrationTimeUTC int64       `json:"registrationTimeUTC"`
        SslPort             *uint16     `json:"sslPort"`
        ServiceType         string      `json:"serviceType"`
        URISpec             *string     `json:"uriSpec"`
}

func (s *ServiceInstance) uniqueHash() []byte <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        buf.Write([]byte(s.ID))
        binary.Write(buf, binary.BigEndian, s.RegistrationTimeUTC)
        return buf.Bytes()
}</span>

// DialString is a string that net.Dial() can accept that will connect to this service's Port
func (s *ServiceInstance) DialString() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%d", s.Address, s.Port)
}</span>

// ChangeWatch is a callback you can register on a service that is executed whenever the service's
// instances change
type ChangeWatch func()

// Service is a set of ServiceInstance that describe a discovered service
type Service struct {
        services atomic.Value // []ServiceInstance
        name     string

        watchLock sync.Mutex
        watches   []ChangeWatch
}

// ZkConn does zookeeper connections
type ZkConn interface {
        GetW(path string) ([]byte, *zk.Stat, &lt;-chan zk.Event, error)
        Create(path string, data []byte, flags int32, acl []zk.ACL) (string, error)
        ChildrenW(path string) ([]string, *zk.Stat, &lt;-chan zk.Event, error)
        ExistsW(path string) (bool, *zk.Stat, &lt;-chan zk.Event, error)
        Delete(path string, version int32) error
        Close()
}

// ZkConnCreator creates Zk connections for disco to use.
type ZkConnCreator interface {
        Connect() (ZkConn, &lt;-chan zk.Event, error)
}

// ZkConnCreatorFunc gives you a ZkConnCreator out of a function
type ZkConnCreatorFunc func() (ZkConn, &lt;-chan zk.Event, error)

// Connect to a zookeeper endpoint
func (z ZkConnCreatorFunc) Connect() (ZkConn, &lt;-chan zk.Event, error) <span class="cov8" title="1">{
        return z()
}</span>

// Disco is a service discovery framework orchestrated via zookeeper
type Disco struct {
        zkConnCreator ZkConnCreator

        zkConn               ZkConn
        eventChan            &lt;-chan zk.Event
        GUIDbytes            [16]byte
        publishAddress       string
        myAdvertisedServices map[string]ServiceInstance
        shouldQuit           chan struct{}
        eventLoopDone        chan struct{}

        watchedMutex    sync.Mutex
        watchedServices map[string]*Service

        manualEvents chan zk.Event

        jsonMarshal func(v interface{}) ([]byte, error)
}

// BuilderConnector satisfies the disco zk connect interface for a zkplus.Builder
func BuilderConnector(b *zkplus.Builder) ZkConnCreator <span class="cov8" title="1">{
        return ZkConnCreatorFunc(func() (ZkConn, &lt;-chan zk.Event, error) </span><span class="cov8" title="1">{
                return b.BuildDirect()
        }</span>)
}

// New creates a disco discovery/publishing service
func New(zkConnCreator ZkConnCreator, publishAddress string) (*Disco, error) <span class="cov8" title="1">{
        return NewRandSource(zkConnCreator, publishAddress, rand.Reader)
}</span>

// NewRandSource creates a disco discovery/publishing service using r as the GUID enthropy
func NewRandSource(zkConnCreator ZkConnCreator, publishAddress string, r io.Reader) (*Disco, error) <span class="cov8" title="1">{
        var GUID [16]byte
        _, err := io.ReadFull(r, GUID[:16])
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">d := &amp;Disco{
                zkConnCreator:        zkConnCreator,
                myAdvertisedServices: make(map[string]ServiceInstance),
                GUIDbytes:            GUID,
                jsonMarshal:          json.Marshal,
                publishAddress:       publishAddress,
                shouldQuit:           make(chan struct{}),
                eventLoopDone:        make(chan struct{}),
                watchedServices:      make(map[string]*Service),
                manualEvents:         make(chan zk.Event),
        }
        d.zkConn, d.eventChan, err = zkConnCreator.Connect()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">go d.eventLoop()
        return d, nil</span>
}

func isServiceModificationEvent(eventType zk.EventType) bool <span class="cov8" title="1">{
        return eventType == zk.EventNodeDataChanged || eventType == zk.EventNodeDeleted || eventType == zk.EventNodeCreated || eventType == zk.EventNodeChildrenChanged
}</span>

func (d *Disco) eventLoop() <span class="cov8" title="1">{
        defer close(d.eventLoopDone)
        for </span><span class="cov8" title="1">{
                select </span>{
                <span class="cov8" title="1">case &lt;-d.shouldQuit:
                        return</span>
                <span class="cov8" title="1">case e := &lt;-d.manualEvents:
                        d.processZkEvent(&amp;e)</span>
                <span class="cov8" title="1">case e := &lt;-d.eventChan:
                        d.processZkEvent(&amp;e)</span>
                }
        }
}

var errServiceDoesNotExist = errors.New("could not find service to refresh")

func (d *Disco) logInfoState(e *zk.Event) bool <span class="cov8" title="1">{
        if e.State == zk.StateDisconnected </span><span class="cov8" title="1">{
                log.WithField("event", e).Info("Disconnected from zookeeper.  Will attempt to remake connection.")
                return true
        }</span>
        <span class="cov8" title="1">if e.State == zk.StateConnecting </span><span class="cov8" title="1">{
                log.WithField("event", e).Info("Server is now attempting to reconnect.")
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (d *Disco) processZkEvent(e *zk.Event) error <span class="cov8" title="1">{
        log.WithField("event", e).Info("Disco event seen")
        d.logInfoState(e)
        if e.State == zk.StateHasSession </span><span class="cov8" title="1">{
                return d.refreshAll()
        }</span>
        <span class="cov8" title="1">serviceName := ""
        if isServiceModificationEvent(e.Type) </span><span class="cov8" title="1">{
                // serviceName is in () /(___)/___
                serviceName = e.Path
                if serviceName[0] == '/' </span><span class="cov8" title="1">{
                        serviceName = serviceName[1:]
                }</span>
                <span class="cov8" title="1">parts := strings.SplitN(serviceName, "/", 2)
                serviceName = parts[0]</span>
        }
        <span class="cov8" title="1">if serviceName != "" </span><span class="cov8" title="1">{
                log.WithField("service", serviceName).Info("Refresh on service")
                service, err := func() (*Service, error) </span><span class="cov8" title="1">{
                        d.watchedMutex.Lock()
                        defer d.watchedMutex.Unlock()
                        s, exist := d.watchedServices[serviceName]
                        if exist </span><span class="cov8" title="1">{
                                return s, nil
                        }</span>
                        <span class="cov8" title="1">return nil, errServiceDoesNotExist</span>
                }()
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        log.WithField("event", e).WithField("parent", serviceName).WithField("err", err).Warn("Unable to find parent")
                }</span><span class="cov8" title="1"> else {
                        log.WithField("service", service).Info("refreshing")
                        return service.refresh(d.zkConn)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Close any open disco connections making this disco unreliable for future updates
// TODO(jack): Close should also delete advertised services
func (d *Disco) Close() <span class="cov8" title="1">{
        close(d.shouldQuit)
        &lt;-d.eventLoopDone
        d.zkConn.Close()
}</span>

func (d *Disco) servicePath(serviceName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("/%s/%s", serviceName, d.GUID())
}</span>

// GUID that this disco advertises itself as
func (d *Disco) GUID() string <span class="cov8" title="1">{
        return fmt.Sprintf("%x", d.GUIDbytes)
}</span>

func (d *Disco) myServiceData(serviceName string, payload interface{}, port uint16) ServiceInstance <span class="cov8" title="1">{
        return ServiceInstance{
                ID:                  d.GUID(),
                Name:                serviceName,
                Payload:             payload,
                Address:             d.publishAddress,
                Port:                port,
                RegistrationTimeUTC: time.Now().UnixNano() / int64(time.Millisecond),
                SslPort:             nil,
                ServiceType:         "DYNAMIC",
                URISpec:             nil,
        }
}</span>

func (d *Disco) refreshAll() error <span class="cov8" title="1">{
        log.Info("Refreshing all zk services")
        d.watchedMutex.Lock()
        defer d.watchedMutex.Unlock()
        for serviceName, serviceInstance := range d.myAdvertisedServices </span><span class="cov8" title="1">{
                log.Infof("Refresh for service %s", serviceName)
                d.advertiseInZK(false, serviceName, serviceInstance)
        }</span>
        <span class="cov8" title="1">for _, service := range d.watchedServices </span><span class="cov8" title="1">{
                service.refresh(d.zkConn)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (d *Disco) advertiseInZK(deleteIfExists bool, serviceName string, instanceData ServiceInstance) error <span class="cov8" title="1">{
        // Need to create service root node
        _, err := d.zkConn.Create(fmt.Sprintf("/%s", serviceName), []byte{}, 0, zk.WorldACL(zk.PermAll))
        if err != nil &amp;&amp; err != zk.ErrNodeExists </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">servicePath := d.servicePath(serviceName)
        exists, stat, _, err := d.zkConn.ExistsW(servicePath)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if !deleteIfExists &amp;&amp; exists </span><span class="cov8" title="1">{
                log.Infof("Service already exists.  Will not delete it")
                return nil
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                log.Infof("Clearing out old service path %s", servicePath)
                // clear out the old version
                if err = d.zkConn.Delete(servicePath, stat.Version); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">instanceBytes, err := d.jsonMarshal(instanceData)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">_, err = d.zkConn.Create(servicePath, instanceBytes, zk.FlagEphemeral, zk.WorldACL(zk.PermAll))
        return err</span>
}

// ErrDuplicateAdvertise is returned by Advertise if users try to Advertise the same service name
// twice
var ErrDuplicateAdvertise = errors.New("service name already advertised")

// Advertise yourself as hosting a service
func (d *Disco) Advertise(serviceName string, payload interface{}, port uint16) (err error) <span class="cov8" title="1">{
        // Note: Important to defer after we release the mutex since the chan send could be a blocking
        //       operation
        defer func() </span><span class="cov8" title="1">{
                log.Infof("Advertise result is %+v", err)
                if err == nil </span><span class="cov8" title="1">{
                        d.manualEvents &lt;- zk.Event{
                                Type:  zk.EventNodeChildrenChanged,
                                State: zk.StateConnected,
                                Path:  serviceName,
                        }
                }</span>
        }()
        <span class="cov8" title="1">d.watchedMutex.Lock()
        defer d.watchedMutex.Unlock()
        log.WithField("name", serviceName).Info("Advertising myself on a service")
        _, exists := d.myAdvertisedServices[serviceName]
        if exists </span><span class="cov8" title="1">{
                return ErrDuplicateAdvertise
        }</span>
        <span class="cov8" title="1">service := d.myServiceData(serviceName, payload, port)
        d.myAdvertisedServices[serviceName] = service
        if err := d.advertiseInZK(true, serviceName, service); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Services advertising for serviceName
func (d *Disco) Services(serviceName string) (*Service, error) <span class="cov8" title="1">{
        d.watchedMutex.Lock()
        defer d.watchedMutex.Unlock()
        s, exist := d.watchedServices[serviceName]
        if exist </span><span class="cov8" title="1">{
                return s, nil
        }</span>
        <span class="cov8" title="1">ret := &amp;Service{
                name: serviceName,
        }
        ret.services.Store([]ServiceInstance{})
        refreshRes := ret.refresh(d.zkConn)
        if refreshRes == nil </span><span class="cov8" title="1">{
                d.watchedServices[serviceName] = ret
                return ret, nil
        }</span>
        <span class="cov8" title="1">return nil, refreshRes</span>
}

// ServiceInstances that represent instances of this service in your system
func (s *Service) ServiceInstances() []ServiceInstance <span class="cov8" title="1">{
        return s.services.Load().([]ServiceInstance)
}</span>

// Watch for changes to the members of this service
func (s *Service) Watch(watch ChangeWatch) <span class="cov8" title="1">{
        s.watchLock.Lock()
        defer s.watchLock.Unlock()
        s.watches = append(s.watches, watch)
}</span>

func (s *Service) String() string <span class="cov8" title="1">{
        s.watchLock.Lock()
        defer s.watchLock.Unlock()
        return fmt.Sprintf("name=%s|len(watch)=%d|instances=%v", s.name, len(s.watches), s.services.Load())
}</span>

func (s *Service) byteHashes() string <span class="cov8" title="1">{
        all := []string{}
        for _, i := range s.ServiceInstances() </span><span class="cov8" title="1">{
                all = append(all, string(i.uniqueHash()))
        }</span>
        <span class="cov8" title="1">slice := sort.StringSlice(all)
        slice.Sort()
        r := ""
        for _, s := range all </span><span class="cov8" title="1">{
                r += s
        }</span>
        <span class="cov8" title="1">return r</span>
}

func childrenServices(serviceName string, children []string, zkConn ZkConn) ([]ServiceInstance, error) <span class="cov8" title="1">{
        log.WithField("serviceName", serviceName).Info("Getting services")
        ret := make([]ServiceInstance, len(children))

        var err error
        var wg sync.WaitGroup
        for index, child := range children </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(child string, instanceAddr *ServiceInstance) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        var bytes []byte
                        var err2 error
                        bytes, _, _, err2 = zkConn.GetW(fmt.Sprintf("/%s/%s", serviceName, child))
                        if err2 != nil </span><span class="cov8" title="1">{
                                err = err2
                                return
                        }</span>
                        <span class="cov8" title="1">err2 = json.Unmarshal(bytes, instanceAddr)
                        if err2 != nil </span><span class="cov8" title="1">{
                                err = err2
                                return
                        }</span>
                }(child, &amp;ret[index]) // &lt;--- Important b/c inside range
        }
        <span class="cov8" title="1">wg.Wait()
        return ret, err</span>
}

func (s *Service) refresh(zkConn ZkConn) error <span class="cov8" title="1">{
        log.WithField("service", s.name).Info("refresh called")
        oldHash := s.byteHashes()
        children, _, _, err := zkConn.ChildrenW(fmt.Sprintf("/%s", s.name))
        if err != nil &amp;&amp; err != zk.ErrNoNode </span><span class="cov8" title="1">{
                log.Warn("Error?")
                return err
        }</span>

        <span class="cov8" title="1">if err == zk.ErrNoNode </span><span class="cov8" title="1">{
                exists, _, _, err := zkConn.ExistsW(fmt.Sprintf("/%s", s.name))
                if exists || err != nil </span><span class="cov8" title="1">{
                        log.WithField("err", err).Warn("Unable to register exists watch!")
                }</span>
                <span class="cov8" title="1">s.services.Store(make([]ServiceInstance, 0))</span>
        }<span class="cov8" title="1"> else {
                services, err := childrenServices(s.name, children, zkConn)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">s.services.Store(services)</span>
        }
        <span class="cov8" title="1">s.watchLock.Lock()
        defer s.watchLock.Unlock()
        newHash := s.byteHashes()
        if oldHash != newHash </span><span class="cov8" title="1">{
                log.Debug("Calling watches")
                for _, w := range s.watches </span><span class="cov8" title="1">{
                        w()
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package disco

import (
        "math/rand"
        "net"

        "time"

        "errors"

        "git.apache.org/thrift.git/lib/go/thrift"
        "github.com/signalfx/golib/logherd"
)

// ThriftTransport can be used as the transport layer for thrift, connecting to services discovered
// by disco
type ThriftTransport struct {
        currentTransport thrift.TTransport
        WrappedFactory   thrift.TTransportFactory
        service          *Service
        randSource       *rand.Rand
        Dialer           net.Dialer
}

var _ thrift.TTransport = &amp;ThriftTransport{}

// NewThriftTransport creates a new ThriftTransport.  The default transport factory is TFramed
func NewThriftTransport(service *Service, timeout time.Duration) *ThriftTransport <span class="cov8" title="1">{
        return &amp;ThriftTransport{
                WrappedFactory: thrift.NewTFramedTransportFactory(thrift.NewTTransportFactory()),
                service:        service,
                randSource:     rand.New(rand.NewSource(time.Now().UnixNano())),
                Dialer: net.Dialer{
                        Timeout: timeout,
                },
        }
}</span>

// Flush the underline transport
func (d *ThriftTransport) Flush() (err error) <span class="cov8" title="1">{
        if d.currentTransport == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">err = d.currentTransport.Flush()
        if err != nil </span><span class="cov8" title="1">{
                d.currentTransport.Close()
                d.currentTransport = nil
        }</span>
        <span class="cov8" title="1">return err</span>
}

// IsOpen will return true if there is a connected underline transport and it is open
func (d *ThriftTransport) IsOpen() bool <span class="cov8" title="1">{
        return d.currentTransport != nil &amp;&amp; d.currentTransport.IsOpen()
}</span>

// Close and nil the underline transport
func (d *ThriftTransport) Close() error <span class="cov8" title="1">{
        if d.currentTransport == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">ret := d.currentTransport.Close()
        d.currentTransport = nil
        return ret</span>
}

// Read bytes from underline transport if it is not nil.  Exact definition defined in TTransport
func (d *ThriftTransport) Read(b []byte) (n int, err error) <span class="cov8" title="1">{
        if d.currentTransport == nil </span><span class="cov8" title="1">{
                return 0, thrift.NewTTransportException(thrift.NOT_OPEN, "")
        }</span>
        <span class="cov8" title="1">n, err = d.currentTransport.Read(b)
        if err != nil </span><span class="cov8" title="1">{
                d.Close()
        }</span>
        <span class="cov8" title="1">return</span>
}

// Write bytes to underline transport if it is not nil.  Exact definition defined in TTransport
func (d *ThriftTransport) Write(b []byte) (n int, err error) <span class="cov8" title="1">{
        if d.currentTransport == nil </span><span class="cov8" title="1">{
                return 0, thrift.NewTTransportException(thrift.NOT_OPEN, "")
        }</span>
        <span class="cov8" title="1">n, err = d.currentTransport.Write(b)
        if err != nil </span><span class="cov8" title="1">{
                d.Close()
        }</span>
        <span class="cov8" title="1">return</span>
}

// ErrNoInstance is returned by NextConnection if the service has no instances
var ErrNoInstance = errors.New("no thrift instances in disco")

// ErrNoInstanceOpen is returned by NextConnection if it cannot connect to any service ports
var ErrNoInstanceOpen = errors.New("no thrift instances is open")

// NextConnection will connect this transport to another random disco service, or return an error
// if no disco service can be dialed
func (d *ThriftTransport) NextConnection() error <span class="cov8" title="1">{
        if d.currentTransport != nil &amp;&amp; d.currentTransport.IsOpen() </span><span class="cov8" title="1">{
                d.currentTransport.Close()
        }</span>
        <span class="cov8" title="1">instances := d.service.ServiceInstances()
        if len(instances) == 0 </span><span class="cov8" title="1">{
                return ErrNoInstance
        }</span>
        <span class="cov8" title="1">logherd.Debug(log, "instances", instances, "Getting next connection")
        startIndex := d.randSource.Intn(len(instances))
        for i := 0; i &lt; len(instances); i++ </span><span class="cov8" title="1">{
                instance := &amp;instances[(startIndex+i)%len(instances)]
                logherd.Debug(log, "instance", instance, "Looking at instance")
                conn, err := d.Dialer.Dial("tcp", instance.DialString())
                if err != nil </span><span class="cov8" title="1">{
                        log.WithField("err", err).Info("Unable to dial instance")
                        continue</span>
                }
                <span class="cov8" title="1">d.currentTransport = d.WrappedFactory.GetTransport(thrift.NewTSocketFromConnTimeout(conn, d.Dialer.Timeout))
                return nil</span>
        }
        <span class="cov8" title="1">d.currentTransport = nil
        return ErrNoInstanceOpen</span>
}

// Open a connection if one does not exist, otherwise do nothing.
func (d *ThriftTransport) Open() error <span class="cov8" title="1">{
        if d.currentTransport == nil || !d.currentTransport.IsOpen() </span><span class="cov8" title="1">{
                return d.NextConnection()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// RemainingBytes of underline transport, or maxSize if not set
func (d *ThriftTransport) RemainingBytes() uint64 <span class="cov8" title="1">{
        if d.currentTransport == nil </span><span class="cov8" title="1">{
                // Looking at the thrift code, I think this is the right thing to do.  This public interface
                // and function is not documented by thrift.
                const maxSize = ^uint64(0)
                return maxSize // the thruth is, we just don't know unless framed is used
        }</span>
        <span class="cov8" title="1">return d.currentTransport.RemainingBytes()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
