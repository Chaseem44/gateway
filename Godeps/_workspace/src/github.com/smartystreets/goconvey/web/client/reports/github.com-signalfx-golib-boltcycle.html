
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/signalfx/golib/boltcycle/boltcycle.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package boltcycle

import (
        "bytes"
        "container/heap"
        "encoding/binary"
        "errors"
        "sync"
        "sync/atomic"

        "github.com/boltdb/bolt"
        "golang.org/x/net/context"
)

// CycleDB allows you to use a bolt.DB as a pseudo-LRU using a cycle of buckets
type CycleDB struct {
        // db is the bolt database values are stored into
        db *bolt.DB

        // bucketTimesIn is the name of the bucket we are putting our rotating values in
        bucketTimesIn []byte

        // minNumOldBuckets ensures you never delete an old bucket during a cycle if you have fewer than
        // these number of buckets
        minNumOldBuckets int
        // Size of read moves to batch into a single transaction
        maxBatchSize int

        // Chan controls backlog of read moves
        readMovements chan readToLocation
        // How large the readMovements chan is when created
        readMovementBacklog int
        // log of errors
        asyncErrors chan&lt;- error

        // wg controls waiting for the read movement loop
        wg sync.WaitGroup
        // stats records useful operation information for reporting back out by the user
        stats Stats

        // Stub functions used for testing
        cursorDelete func(*bolt.Cursor) error
}

// Stats are exported by CycleDB to let users inspect its behavior over time
type Stats struct {
        TotalItemsRecopied            int64
        TotalItemsAsyncPut            int64
        RecopyTransactionCount        int64
        TotalItemsDeletedDuringRecopy int64
        TotalReadCount                int64
        TotalWriteCount               int64
        TotalDeleteCount              int64
        TotalCycleCount               int64
        TotalErrorsDuringRecopy       int64
        SizeOfBacklogToCopy           int
}

func (s *Stats) atomicClone() Stats <span class="cov8" title="1">{
        return Stats{
                TotalItemsRecopied:            atomic.LoadInt64(&amp;s.TotalItemsRecopied),
                TotalItemsAsyncPut:            atomic.LoadInt64(&amp;s.TotalItemsAsyncPut),
                RecopyTransactionCount:        atomic.LoadInt64(&amp;s.RecopyTransactionCount),
                TotalItemsDeletedDuringRecopy: atomic.LoadInt64(&amp;s.TotalItemsDeletedDuringRecopy),
                TotalReadCount:                atomic.LoadInt64(&amp;s.TotalReadCount),
                TotalWriteCount:               atomic.LoadInt64(&amp;s.TotalWriteCount),
                TotalDeleteCount:              atomic.LoadInt64(&amp;s.TotalDeleteCount),
                TotalCycleCount:               atomic.LoadInt64(&amp;s.TotalCycleCount),
                TotalErrorsDuringRecopy:       atomic.LoadInt64(&amp;s.TotalErrorsDuringRecopy),
        }
}</span>

var errUnableToFindRootBucket = errors.New("unable to find root bucket")
var errUnexpectedBucketBytes = errors.New("bucket bytes not in uint64 form")
var errUnexpectedNonBucket = errors.New("unexpected non bucket")
var errNoLastBucket = errors.New("unable to find a last bucket")
var errOrderingWrong = errors.New("ordering wrong")

// KvPair is a pair of key/value that you want to write during a write call
type KvPair struct {
        // Key to write
        Key []byte
        // Value to write for key
        Value []byte
}

var defaultBucketName = []byte("cyc")

// DBConfiguration are callbacks used as optional vardic parameters in New() to configure DB usage
type DBConfiguration func(*CycleDB) error

// CycleLen sets the number of old buckets to keep around
func CycleLen(minNumOldBuckets int) DBConfiguration <span class="cov8" title="1">{
        return func(c *CycleDB) error </span><span class="cov8" title="1">{
                c.minNumOldBuckets = minNumOldBuckets
                return nil
        }</span>
}

// ReadMovementBacklog sets the size of the channel of read operations to rewrite
func ReadMovementBacklog(readMovementBacklog int) DBConfiguration <span class="cov8" title="1">{
        return func(c *CycleDB) error </span><span class="cov8" title="1">{
                c.readMovementBacklog = readMovementBacklog
                return nil
        }</span>
}

// AsyncErrors controls where we log async errors into.  If nil, they are silently dropped
func AsyncErrors(asyncErrors chan&lt;- error) DBConfiguration <span class="cov8" title="1">{
        return func(c *CycleDB) error </span><span class="cov8" title="1">{
                c.asyncErrors = asyncErrors
                return nil
        }</span>
}

// BucketTimesIn is the sub bucket we put our cycled hashmap into
func BucketTimesIn(bucketName []byte) DBConfiguration <span class="cov8" title="1">{
        return func(c *CycleDB) error </span><span class="cov8" title="1">{
                c.bucketTimesIn = bucketName
                return nil
        }</span>
}

// New creates a CycleDB to use a bolt database that cycles minNumOldBuckets buckets
func New(db *bolt.DB, optionalParameters ...DBConfiguration) (*CycleDB, error) <span class="cov8" title="1">{
        ret := &amp;CycleDB{
                db:                  db,
                bucketTimesIn:       defaultBucketName,
                minNumOldBuckets:    2,
                maxBatchSize:        1000,
                readMovementBacklog: 10000,
                cursorDelete: func(c *bolt.Cursor) error </span><span class="cov8" title="1">{
                        return c.Delete()
                }</span>,
        }
        <span class="cov8" title="1">for _, config := range optionalParameters </span><span class="cov8" title="1">{
                if err := config(ret); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if err := ret.init(); err != nil </span><span class="cov8" title="1">{
                return ret, err
        }</span>
        <span class="cov8" title="1">if !db.IsReadOnly() </span><span class="cov8" title="1">{
                ret.wg.Add(1)
                ret.readMovements = make(chan readToLocation, ret.readMovementBacklog)
                go ret.readMovementLoop()
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

// Stats returns introspection stats about the Database.  The members are considered alpha and
// subject to change or rename.
func (c *CycleDB) Stats() Stats <span class="cov8" title="1">{
        ret := c.stats.atomicClone()
        ret.SizeOfBacklogToCopy = len(c.readMovements)
        return ret
}</span>

// Close ends the goroutine that moves read items to the latest bucket
func (c *CycleDB) Close() error <span class="cov8" title="1">{
        if !c.db.IsReadOnly() </span><span class="cov8" title="1">{
                close(c.readMovements)
        }</span>
        <span class="cov8" title="1">c.wg.Wait()
        return nil</span>
}

type stringCursor struct {
        cursor *bolt.Cursor
        head   string
}

type cursorHeap []stringCursor

func (c cursorHeap) Len() int <span class="cov8" title="1">{
        return len(c)
}</span>

func (c cursorHeap) Less(i, j int) bool <span class="cov8" title="1">{
        return c[i].head &lt; c[j].head
}</span>

func (c cursorHeap) Swap(i, j int) <span class="cov8" title="1">{
        c[i], c[j] = c[j], c[i]
}</span>

func (c *cursorHeap) Push(x interface{}) <span class="cov8" title="1">{
        item := x.(stringCursor)
        *c = append(*c, item)
}</span>

func (c *cursorHeap) Pop() interface{} <span class="cov8" title="1">{
        n := len(*c)
        item := (*c)[n-1]
        *c = (*c)[0 : n-1]
        return item
}</span>

var _ heap.Interface = &amp;cursorHeap{}

func (c *CycleDB) init() error <span class="cov8" title="1">{
        if c.db.IsReadOnly() </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return c.db.Update(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                bucket, err := tx.CreateBucketIfNotExists(c.bucketTimesIn)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                // If there is no bucket at all, make a first bucket at key=[0,0,0,0, 0,0,0,1]
                // Because we special case bucket zero, start at 1 not zero.
                <span class="cov8" title="1">if k, _ := bucket.Cursor().First(); k == nil </span><span class="cov8" title="1">{
                        var b [8]byte

                        _, err := bucket.CreateBucket(nextKey(b[:]))
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
}

// VerifyBuckets ensures that the cycle of buckets have the correct names (increasing 8 byte integers)
func (c *CycleDB) VerifyBuckets() error <span class="cov8" title="1">{
        return c.db.View(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                bucket := tx.Bucket(c.bucketTimesIn)
                if bucket == nil </span><span class="cov8" title="1">{
                        return errUnableToFindRootBucket
                }</span>

                // Each bucket should be 8 bytes of different uint64
                <span class="cov8" title="1">return bucket.ForEach(func(k, v []byte) error </span><span class="cov8" title="1">{
                        if v != nil </span><span class="cov8" title="1">{
                                return errUnexpectedNonBucket
                        }</span>
                        <span class="cov8" title="1">if len(k) != 8 </span><span class="cov8" title="1">{
                                return errUnexpectedBucketBytes
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                })
        })
}

func createHeap(bucket *bolt.Bucket) (cursorHeap, error) <span class="cov8" title="1">{
        var ch cursorHeap
        // Each bucket should be 8 bytes of different uint64
        err := bucket.ForEach(func(k, v []byte) error </span><span class="cov8" title="1">{
                cursor := bucket.Bucket(k).Cursor()
                firstKey, _ := cursor.First()
                if firstKey != nil </span><span class="cov8" title="1">{
                        ch = append(ch, stringCursor{cursor: cursor, head: string(firstKey)})
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">return ch, err</span>
}

func verifyHeap(ch cursorHeap) error <span class="cov8" title="1">{
        top := ""
        heap.Init(&amp;ch)
        for len(ch) &gt; 0 </span><span class="cov8" title="1">{
                nextTop := ch[0].head
                if top != "" &amp;&amp; nextTop &lt;= top </span><span class="cov8" title="1">{
                        return errOrderingWrong
                }</span>
                <span class="cov8" title="1">top = nextTop
                headBytes, _ := ch[0].cursor.Next()
                if headBytes == nil </span><span class="cov8" title="1">{
                        heap.Pop(&amp;ch)
                }</span><span class="cov8" title="1"> else {
                        ch[0].head = string(headBytes)
                        heap.Fix(&amp;ch, 0)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

var createHeapFunc = createHeap

// VerifyCompressed checks that no key is repeated in the database
func (c *CycleDB) VerifyCompressed() error <span class="cov8" title="1">{
        return c.db.View(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                bucket := tx.Bucket(c.bucketTimesIn)
                if bucket == nil </span><span class="cov8" title="1">{
                        return errUnableToFindRootBucket
                }</span>

                <span class="cov8" title="1">ch, err := createHeapFunc(bucket)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">return verifyHeap(ch)</span>
        })
}

// CycleNodes deletes the first, oldest node in the primary bucket while there are &gt;= minNumOldBuckets
// and creates a new, empty last node
func (c *CycleDB) CycleNodes() error <span class="cov8" title="1">{
        atomic.AddInt64(&amp;c.stats.TotalCycleCount, int64(1))
        return c.db.Update(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                bucket := tx.Bucket(c.bucketTimesIn)
                if bucket == nil </span><span class="cov8" title="1">{
                        return errUnableToFindRootBucket
                }</span>

                <span class="cov8" title="1">countBuckets := func() int </span><span class="cov8" title="1">{
                        num := 0
                        cursor := bucket.Cursor()
                        for k, _ := cursor.First(); k != nil; k, _ = cursor.Next() </span><span class="cov8" title="1">{
                                num++
                        }</span>
                        <span class="cov8" title="1">return num</span>
                }()

                <span class="cov8" title="1">cursor := bucket.Cursor()
                for k, _ := cursor.First(); k != nil &amp;&amp; countBuckets &gt; c.minNumOldBuckets; k, _ = cursor.Next() </span><span class="cov8" title="1">{
                        if err := bucket.DeleteBucket(k); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">countBuckets--</span>
                }

                <span class="cov8" title="1">lastBucket, _ := cursor.Last()
                nextBucketName := nextKey(lastBucket)
                _, err := bucket.CreateBucket(nextBucketName)

                return err</span>
        })
}

func nextKey(last []byte) []byte <span class="cov8" title="1">{
        lastNum := binary.BigEndian.Uint64(last)
        var ret [8]byte
        binary.BigEndian.PutUint64(ret[:], lastNum+1)
        return ret[:]
}</span>

type readToLocation struct {
        // bucket we found the []byte key in
        bucket uint64
        // Key we searched for
        key []byte
        // Value we found for the key, or nil of it wasn't found
        value []byte
        // needsCopy is true if we detected this item needs to be copied to the last bucket
        needsCopy bool
}

func (c *CycleDB) readMovementLoop() <span class="cov8" title="1">{
        defer c.wg.Done()
        for </span><span class="cov8" title="1">{
                allMovements := drainAllMovements(c.readMovements, c.maxBatchSize)
                if allMovements == nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">if err := c.moveRecentReads(allMovements); err != nil </span><span class="cov8" title="1">{
                        atomic.AddInt64(&amp;c.stats.TotalErrorsDuringRecopy, 1)
                        if c.asyncErrors != nil </span><span class="cov8" title="1">{
                                c.asyncErrors &lt;- err
                        }</span>
                }
        }
}

func drainAllMovements(readMovements &lt;-chan readToLocation, maxBatchSize int) []readToLocation <span class="cov8" title="1">{
        allMovements := make([]readToLocation, 0, maxBatchSize)
        var rm readToLocation
        var ok bool
        if rm, ok = &lt;-readMovements; !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">allMovements = append(allMovements, rm)

        for len(allMovements) &lt; maxBatchSize </span><span class="cov8" title="1">{
                select </span>{
                <span class="cov8" title="1">case rm, ok := &lt;-readMovements:
                        if !ok </span><span class="cov8" title="1">{
                                return allMovements
                        }</span>
                        <span class="cov8" title="1">allMovements = append(allMovements, rm)</span>
                <span class="cov8" title="1">default:
                        return allMovements</span>
                }
        }
        <span class="cov8" title="1">return allMovements</span>
}

func (c *CycleDB) indexToLocation(toread [][]byte) ([]readToLocation, error) <span class="cov8" title="1">{
        res := make([]readToLocation, len(toread))

        indexesToFetch := make(map[int][]byte, len(toread))
        for i, bytes := range toread </span><span class="cov8" title="1">{
                indexesToFetch[i] = bytes
        }</span>

        <span class="cov8" title="1">err := c.db.View(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                bucket := tx.Bucket(c.bucketTimesIn)
                if bucket == nil </span><span class="cov8" title="1">{
                        return errUnableToFindRootBucket
                }</span>
                <span class="cov8" title="1">timeCursor := bucket.Cursor()
                needsCopy := false

                // We read values from the end to the start.  The last bucket is where we expect a read
                // heavy workload to have the key
                for lastKey, _ := timeCursor.Last(); lastKey != nil &amp;&amp; len(indexesToFetch) &gt; 0; lastKey, _ = timeCursor.Prev() </span><span class="cov8" title="1">{

                        // All subkeys of our tree should be buckets
                        timeBucket := bucket.Bucket(lastKey)
                        if timeBucket == nil </span><span class="cov8" title="1">{
                                return errUnexpectedNonBucket
                        }</span>
                        <span class="cov8" title="1">bucketAsUint := binary.BigEndian.Uint64(lastKey)

                        timeBucketCursor := timeBucket.Cursor()
                        for index, searchBytes := range indexesToFetch </span><span class="cov8" title="1">{
                                key, value := timeBucketCursor.Seek(searchBytes)
                                if key == nil </span><span class="cov8" title="1">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">if bytes.Equal(key, searchBytes) </span><span class="cov8" title="1">{
                                        res[index].key = searchBytes
                                        res[index].value = make([]byte, len(value))
                                        // Note: The returned value is only valid for the lifetime of the transaction so
                                        //       we must copy it out
                                        copy(res[index].value, value)
                                        res[index].bucket = bucketAsUint
                                        res[index].needsCopy = needsCopy

                                        // We can remove this item since we don't need to search for it later
                                        delete(indexesToFetch, index)
                                }</span>
                        }
                        <span class="cov8" title="1">needsCopy = true</span>
                }
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">return res, err</span>
}

func (c *CycleDB) moveRecentReads(readLocations []readToLocation) error <span class="cov8" title="1">{
        bucketIDToReadLocations := make(map[uint64][]readToLocation)
        for _, r := range readLocations </span><span class="cov8" title="1">{
                bucketIDToReadLocations[r.bucket] = append(bucketIDToReadLocations[r.bucket], r)
        }</span>
        <span class="cov8" title="1">return c.db.Update(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;c.stats.RecopyTransactionCount, int64(1))
                bucket := tx.Bucket(c.bucketTimesIn)
                if bucket == nil </span><span class="cov8" title="1">{
                        return errUnableToFindRootBucket
                }</span>
                <span class="cov8" title="1">lastBucketKey, _ := bucket.Cursor().Last()
                if lastBucketKey == nil </span><span class="cov8" title="1">{
                        return errNoLastBucket
                }</span>
                <span class="cov8" title="1">lastBucket := bucket.Bucket(lastBucketKey)
                if lastBucket == nil </span><span class="cov8" title="1">{
                        return errNoLastBucket
                }</span>

                <span class="cov8" title="1">recopyCount := int64(0)
                deletedCount := int64(0)
                asyncPutCount := int64(0)

                for bucketID, readLocs := range bucketIDToReadLocations </span><span class="cov8" title="1">{
                        if bucketID != 0 </span><span class="cov8" title="1">{
                                if err := deleteFromOldBucket(bucketID, readLocs, bucket, c.cursorDelete, &amp;recopyCount, &amp;deletedCount); err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">for _, rs := range readLocs </span><span class="cov8" title="1">{
                                asyncPutCount++
                                if err := lastBucket.Put(rs.key, rs.value); err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov8" title="1">atomic.AddInt64(&amp;c.stats.TotalItemsRecopied, recopyCount)
                atomic.AddInt64(&amp;c.stats.TotalItemsAsyncPut, asyncPutCount)
                atomic.AddInt64(&amp;c.stats.TotalItemsDeletedDuringRecopy, deletedCount)
                return nil</span>
        })
}

func deleteFromOldBucket(bucketID uint64, readLocs []readToLocation, bucket *bolt.Bucket, cursorDelete func(*bolt.Cursor) error, recopyCount *int64, deletedCount *int64) error <span class="cov8" title="1">{
        var bucketName [8]byte
        binary.BigEndian.PutUint64(bucketName[:], bucketID)
        oldBucket := bucket.Bucket(bucketName[:])
        if oldBucket != nil </span><span class="cov8" title="1">{
                oldBucketCursor := oldBucket.Cursor()
                for _, rs := range readLocs </span><span class="cov8" title="1">{
                        k, _ := oldBucketCursor.Seek(rs.key)
                        *recopyCount++
                        if k != nil &amp;&amp; bytes.Equal(k, rs.key) </span><span class="cov8" title="1">{
                                if err := cursorDelete(oldBucketCursor); err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">*deletedCount++</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// Read bytes from the first available bucket
func (c *CycleDB) Read(toread [][]byte) ([][]byte, error) <span class="cov8" title="1">{
        atomic.AddInt64(&amp;c.stats.TotalReadCount, int64(len(toread)))
        readLocations, err := c.indexToLocation(toread)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !c.db.IsReadOnly() </span><span class="cov8" title="1">{
                for _, readLocation := range readLocations </span><span class="cov8" title="1">{
                        if readLocation.needsCopy </span><span class="cov8" title="1">{
                                c.readMovements &lt;- readLocation
                        }</span>
                }
        }

        <span class="cov8" title="1">res := make([][]byte, len(readLocations))
        for i, rl := range readLocations </span><span class="cov8" title="1">{
                res[i] = rl.value
        }</span>
        <span class="cov8" title="1">return res, nil</span>
}

// AsyncWrite will enqueue a write into the same chan that moves reads to the last bucket.  You
// must not *ever* change the []byte given to towrite since you can't know when that []byte is
// finished being used.  Note that if the readMovements queue is backed up this operation will block
// until it has room.
func (c *CycleDB) AsyncWrite(ctx context.Context, towrite []KvPair) <span class="cov8" title="1">{
        for _, w := range towrite </span><span class="cov8" title="1">{
                select </span>{
                <span class="cov8" title="1">case &lt;- ctx.Done():
                        return</span>
                <span class="cov8" title="1">case c.readMovements &lt;- readToLocation{
                                key:   w.Key,
                                value: w.Value,
                        }:</span>
                }
        }
}

// Write a pair of key/value items into the cycle disk
func (c *CycleDB) Write(towrite []KvPair) error <span class="cov8" title="1">{
        atomic.AddInt64(&amp;c.stats.TotalWriteCount, int64(len(towrite)))
        return c.db.Update(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                bucket := tx.Bucket(c.bucketTimesIn)
                if bucket == nil </span><span class="cov8" title="1">{
                        return errUnableToFindRootBucket
                }</span>
                <span class="cov8" title="1">lastBucketKey, _ := bucket.Cursor().Last()
                if lastBucketKey == nil </span><span class="cov8" title="1">{
                        return errNoLastBucket
                }</span>
                <span class="cov8" title="1">lastBucket := bucket.Bucket(lastBucketKey)
                if lastBucket == nil </span><span class="cov8" title="1">{
                        return errNoLastBucket
                }</span>
                <span class="cov8" title="1">for _, p := range towrite </span><span class="cov8" title="1">{
                        if err := lastBucket.Put(p.Key, p.Value); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        })
}

// Delete all the keys from every bucket that could have the keys.  Returns true/false for each key
// if it exists
func (c *CycleDB) Delete(keys [][]byte) ([]bool, error) <span class="cov8" title="1">{
        atomic.AddInt64(&amp;c.stats.TotalDeleteCount, int64(len(keys)))
        ret := make([]bool, len(keys))
        return ret, c.db.Update(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                bucket := tx.Bucket(c.bucketTimesIn)
                if bucket == nil </span><span class="cov8" title="1">{
                        return errUnableToFindRootBucket
                }</span>
                <span class="cov8" title="1">return bucket.ForEach(func(k, v []byte) error </span><span class="cov8" title="1">{
                        innerBucket := bucket.Bucket(k)
                        if innerBucket == nil </span><span class="cov8" title="1">{
                                return errUnexpectedNonBucket
                        }</span>
                        <span class="cov8" title="1">cursor := innerBucket.Cursor()
                        return deleteKeys(keys, cursor, ret)</span>
                })
        })
}

func deleteKeys(keys [][]byte, cursor *bolt.Cursor, ret []bool) error <span class="cov8" title="1">{
        for index, key := range keys </span><span class="cov8" title="1">{
                k, _ := cursor.Seek(key)
                if bytes.Equal(k, key) </span><span class="cov8" title="1">{
                        if err := cursor.Delete(); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">ret[index] = true</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
