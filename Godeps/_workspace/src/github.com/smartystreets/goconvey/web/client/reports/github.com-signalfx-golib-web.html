
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/signalfx/golib/web/closeheader.go (100.0%)</option>
				
				<option value="file1">github.com/signalfx/golib/web/reqcounter.go (100.0%)</option>
				
				<option value="file2">github.com/signalfx/golib/web/starttime.go (100.0%)</option>
				
				<option value="file3">github.com/signalfx/golib/web/web.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package web

import (
        "net/http"
        "sync/atomic"

        "golang.org/x/net/context"
)

// CloseHeader is used to control when connections should signal they should be closed
type CloseHeader struct {
        SetCloseHeader int32
}

// OptionallyAddCloseHeader will set Connection: Close on the response if SetCloseHeader is non zero
func (c *CloseHeader) OptionallyAddCloseHeader(ctx context.Context, rw http.ResponseWriter, r *http.Request, next ContextHandler) <span class="cov8" title="1">{
        if atomic.LoadInt32(&amp;c.SetCloseHeader) != 0 </span><span class="cov8" title="1">{
                rw.Header().Set("Connection", "Close")
        }</span>
        <span class="cov8" title="1">next.ServeHTTPC(ctx, rw, r)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package web

import (
        "net/http"
        "sync/atomic"
        "time"

        "github.com/signalfx/golib/datapoint"
)

// RequestCounter is a negroni handler that tracks connection stats
type RequestCounter struct {
        TotalConnections      int64
        ActiveConnections     int64
        TotalProcessingTimeNs int64
}

var _ HTTPConstructor = (&amp;RequestCounter{}).Wrap
var _ NextHTTP = (&amp;RequestCounter{}).ServeHTTP

// Wrap returns a handler that forwards calls to next and counts the calls forwarded
func (m *RequestCounter) Wrap(next http.Handler) http.Handler <span class="cov8" title="1">{
        f := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                m.ServeHTTP(w, r, next)
        }</span>
        <span class="cov8" title="1">return http.HandlerFunc(f)</span>
}

func (m *RequestCounter) ServeHTTP(rw http.ResponseWriter, r *http.Request, next http.Handler) <span class="cov8" title="1">{
        atomic.AddInt64(&amp;m.TotalConnections, 1)
        atomic.AddInt64(&amp;m.ActiveConnections, 1)
        defer atomic.AddInt64(&amp;m.ActiveConnections, -1)
        start := time.Now()
        next.ServeHTTP(rw, r)
        reqDuration := time.Since(start)
        atomic.AddInt64(&amp;m.TotalProcessingTimeNs, reqDuration.Nanoseconds())
}</span>

// Stats returns stats on total connections, active connections, and total processing time
func (m *RequestCounter) Stats(dimensions map[string]string) []*datapoint.Datapoint <span class="cov8" title="1">{
        ret := []*datapoint.Datapoint{}
        stats := map[string]int64{
                "total_connections": atomic.LoadInt64(&amp;m.TotalConnections),
                "total_time_ns":     atomic.LoadInt64(&amp;m.TotalProcessingTimeNs),
        }
        for k, v := range stats </span><span class="cov8" title="1">{
                ret = append(
                        ret,
                        datapoint.New(
                                k,
                                dimensions,
                                datapoint.NewIntValue(v),
                                datapoint.Counter,
                                time.Now()))
        }</span>
        <span class="cov8" title="1">ret = append(
                ret,
                datapoint.New(
                        "active_connections",
                        dimensions,
                        datapoint.NewIntValue(atomic.LoadInt64(&amp;m.ActiveConnections)),
                        datapoint.Gauge,
                        time.Now()))
        return ret</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package web

import (
        "net/http"
        "time"

        "golang.org/x/net/context"
)

// AddRequestTime is a web context that adds the current time to the request's context
func AddRequestTime(ctx context.Context, rw http.ResponseWriter, r *http.Request, next ContextHandler) <span class="cov8" title="1">{
        next.ServeHTTPC(AddTime(ctx, time.Now()), rw, r)
}</span>

type metadata int

const (
        requestTime metadata = iota
)

// AddTime will add now to the context's time.  You can get now later with RequestTime
func AddTime(ctx context.Context, now time.Time) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, requestTime, now)
}</span>

// RequestTime looks at the context to return the time added with AddTime
func RequestTime(ctx context.Context) time.Time <span class="cov8" title="1">{
        return ctx.Value(requestTime).(time.Time)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package web

import (
        "net/http"
        "sync"

        "golang.org/x/net/context"
)

// Note: Borrowed greatly from goji, but I would rather use context as the middleware context than
//       something else

// ContextHandler is just like http.Handler but also takes a context
type ContextHandler interface {
        ServeHTTPC(ctx context.Context, rw http.ResponseWriter, r *http.Request)
}

// HandlerFunc can turn a func() into a ContextHandler
type HandlerFunc func(ctx context.Context, rw http.ResponseWriter, r *http.Request)

// ServeHTTPC calls the underline func
func (h HandlerFunc) ServeHTTPC(ctx context.Context, rw http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        h(ctx, rw, r)
}</span>

// FromHTTP creates a ContextHandler from a http.Handler by throwing away the context
func FromHTTP(f http.Handler) ContextHandler <span class="cov8" title="1">{
        return HandlerFunc(func(_ context.Context, rw http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                f.ServeHTTP(rw, r)
        }</span>)
}

// ToHTTP converts a ContextHandler into a http.Handler by calling c() with the added ctx
func ToHTTP(ctx context.Context, c ContextHandler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                c.ServeHTTPC(ctx, rw, r)
        }</span>)
}

// Constructor defines how we creates context handling middleware
type Constructor interface {
        CreateMiddleware(next ContextHandler) ContextHandler
}

// ConstructorFunc allows a func to become a Constructor
type ConstructorFunc func(next ContextHandler) ContextHandler

// CreateMiddleware calls the underline function
func (c ConstructorFunc) CreateMiddleware(next ContextHandler) ContextHandler <span class="cov8" title="1">{
        return c(next)
}</span>

// NextConstructor creates a Constructor that calls the given function to forward requests
type NextConstructor func(ctx context.Context, rw http.ResponseWriter, r *http.Request, next ContextHandler)

// CreateMiddleware returns a middleware layer that passes next to n()
func (n NextConstructor) CreateMiddleware(next ContextHandler) ContextHandler <span class="cov8" title="1">{
        return HandlerFunc(func(ctx context.Context, rw http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                n(ctx, rw, r, next)
        }</span>)
}

// NextHTTP is like NextConstructor but when the next praameter is a http.Handler
type NextHTTP func(rw http.ResponseWriter, r *http.Request, next http.Handler)

// CreateMiddleware creates a middleware layer that saves the context for the next layer
func (n NextHTTP) CreateMiddleware(next ContextHandler) ContextHandler <span class="cov8" title="1">{
        return HandlerFunc(func(ctx context.Context, rw http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                n(rw, r, http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        next.ServeHTTPC(ctx, rw, r)
                }</span>))
        })
}

// HTTPConstructor is generally discouraged but allows us to turn a normal http.Handler constructor
// into a context constructor
type HTTPConstructor func(next http.Handler) http.Handler

type outerWrap struct {
        next ContextHandler
        ctx  context.Context
}

func (o *outerWrap) ServeHTTP(rw http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        o.next.ServeHTTPC(o.ctx, rw, r)
}</span>

// CreateMiddleware creates a middleware layer for a HTTPConstructor.  It is unsafe to call this
// ContextHandler from multiple threads.  Our Handler layer will make sure this doesn't happen
func (h HTTPConstructor) CreateMiddleware(next ContextHandler) ContextHandler <span class="cov8" title="1">{
        o := outerWrap{
                next: next,
        }
        outer := h(&amp;o)
        return HandlerFunc(func(ctx context.Context, rw http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                //                // TODO: A million dollars to who can figure out how to do this cleaner with the called
                //                //       function really owning this context while also not calling h() each time
                if o.ctx != nil </span><span class="cov8" title="1">{
                        panic("I was never reset.  Logic error!")
                }</span>
                <span class="cov8" title="1">o.ctx = ctx
                outer.ServeHTTP(rw, r)
                o.ctx = nil</span>
        })
}

// Handler turns a stack of HTTP handlers into a single handler that threads a context between each
type Handler struct {
        Ending          ContextHandler
        Chain           []Constructor
        StartingContext context.Context
        Pool            sync.Pool
}

func (h *Handler) newStack() ContextHandler <span class="cov8" title="1">{
        result := h.Ending
        for i := len(h.Chain) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                result = h.Chain[i].CreateMiddleware(result)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Add a middleware layer to this handler
func (h *Handler) Add(parts ...Constructor) *Handler <span class="cov8" title="1">{
        h.Chain = append(h.Chain, parts...)
        return h
}</span>

// ServeHTTP passes the default starting context
func (h *Handler) ServeHTTP(rw http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        h.ServeHTTPC(h.StartingContext, rw, r)
}</span>

// ServeHTTPC will pass the request between each middleware layer
func (h *Handler) ServeHTTPC(ctx context.Context, rw http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        stack := h.Pool.Get().(ContextHandler)
        stack.ServeHTTPC(ctx, rw, r)
        h.Pool.Put(stack)
}</span>

//NewHandler creates a new handler with no middleware layers
func NewHandler(StartingContext context.Context, Ending ContextHandler) *Handler <span class="cov8" title="1">{
        h := &amp;Handler{
                Ending:          Ending,
                Chain:           []Constructor{},
                StartingContext: StartingContext,
        }
        h.Pool.New = func() interface{} </span><span class="cov8" title="1">{
                return h.newStack()
        }</span>
        <span class="cov8" title="1">return h</span>
}

// VarAdder is a middleware layer that adds to the context Key/Value
type VarAdder struct {
        Key   interface{}
        Value interface{}
}

// Generate creates the next middleware layer for VarAdder
func (i *VarAdder) Generate(next ContextHandler) ContextHandler <span class="cov8" title="1">{
        return HandlerFunc(func(ctx context.Context, rw http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                next.ServeHTTPC(context.WithValue(ctx, i.Key, i.Value), rw, r)
        }</span>)
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
