
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/signalfx/golib/zkplus/builder.go (100.0%)</option>
				
				<option value="file1">github.com/signalfx/golib/zkplus/zkplus.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package zkplus

import (
        "fmt"
        "time"

        log "github.com/Sirupsen/logrus"
        "github.com/samuel/go-zookeeper/zk"
        "github.com/signalfx/golib/zkplus/zktest"
)

// Builder helps users build a ZkPlus connection
type Builder struct {
        pathPrefix  string
        zkConnector ZkConnector
}

// NewBuilder creates a new builder for making ZkPlus connections
func NewBuilder() *Builder <span class="cov8" title="1">{
        return &amp;Builder{
                pathPrefix: "",
        }
}</span>

// DialZkConnector sets how zk network connections are created
func (b *Builder) DialZkConnector(servers []string, sessionTimeout time.Duration, dialer zk.Dialer) *Builder <span class="cov8" title="1">{
        b.zkConnector = ZkConnectorFunc(func() (zktest.ZkConnSupported, &lt;-chan zk.Event, error) </span><span class="cov8" title="1">{
                return zk.ConnectWithDialer(servers, sessionTimeout, dialer)
        }</span>)
        <span class="cov8" title="1">return b</span>
}

// Connector sets what we use to create zk connections
func (b *Builder) Connector(zkConnector ZkConnector) *Builder <span class="cov8" title="1">{
        b.zkConnector = zkConnector
        return b
}</span>

// PathPrefix is the prefix any zk operations get
func (b *Builder) PathPrefix(pathPrefix string) *Builder <span class="cov8" title="1">{
        b.pathPrefix = pathPrefix
        return b
}</span>

// ZkPlus copies the config from another connection
func (b *Builder) ZkPlus(zkPlus *ZkPlus) *Builder <span class="cov8" title="1">{
        b.pathPrefix = zkPlus.pathPrefix
        b.zkConnector = zkPlus.zkConnector
        return b
}</span>

// AppendPathPrefix to the existing path.  Can be chained to create /a/b/c directories
func (b *Builder) AppendPathPrefix(childPath string) *Builder <span class="cov8" title="1">{
        b.pathPrefix = fmt.Sprintf("%s/%s", b.pathPrefix, childPath)
        return b
}</span>

// BuildDirect is a helper that looks like the regular zk create function
func (b *Builder) BuildDirect() (*ZkPlus, &lt;-chan zk.Event, error) <span class="cov8" title="1">{
        z, err := b.Build()
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">return z, z.EventChan(), nil</span>
}

// Build a ZkPlus connection, returning an error if the path doesn't make sense
func (b *Builder) Build() (*ZkPlus, error) <span class="cov8" title="1">{
        prefix := b.pathPrefix
        if len(prefix) == 0 </span><span class="cov8" title="1">{
                prefix = ""
        }</span><span class="cov8" title="1"> else if prefix[0] != '/' </span><span class="cov8" title="1">{
                return nil, errInvalidPathPrefix
        }</span><span class="cov8" title="1"> else if prefix[len(prefix)-1] == '/' </span><span class="cov8" title="1">{
                return nil, errInvalidPathSuffix
        }</span>
        // Prefix is of the form /..... (then no ending /) or empty string
        <span class="cov8" title="1">log.WithField("prefix", prefix).Info("New with prefix")

        ret := &amp;ZkPlus{
                pathPrefix:  prefix,
                zkConnector: b.zkConnector,
                exposedChan: make(chan zk.Event),
                shouldQuit:  make(chan chan struct{}),
                askForConn:  make(chan chan zktest.ZkConnSupported),
        }
        go ret.eventLoop()
        return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package zkplus

import (
        "errors"
        "fmt"
        "strings"

        "time"

        log "github.com/Sirupsen/logrus"
        "github.com/samuel/go-zookeeper/zk"
        "github.com/signalfx/golib/zkplus/zktest"
)

// ZkConnector tells ZkPlus how to create a zk connection
type ZkConnector interface {
        Conn() (zktest.ZkConnSupported, &lt;-chan zk.Event, error)
}

// ZkConnectorFunc is a helper to wrap a simple function for making Zk connections
type ZkConnectorFunc func() (zktest.ZkConnSupported, &lt;-chan zk.Event, error)

// Conn to a Zk Connection, calling itself to create the connection
func (f ZkConnectorFunc) Conn() (zktest.ZkConnSupported, &lt;-chan zk.Event, error) <span class="cov8" title="1">{
        return f()
}</span>

// A StaticConnector will always return the same connection and chan for every connection request.
// Usually only needed for testing
type StaticConnector struct {
        C  zktest.ZkConnSupported
        Ch &lt;-chan zk.Event
}

// Conn will just return the constructed connection and event channel
func (s *StaticConnector) Conn() (zktest.ZkConnSupported, &lt;-chan zk.Event, error) <span class="cov8" title="1">{
        return s.C, s.Ch, nil
}</span>

// ZkPlus wraps a zookeeper connection to provide namespacing, auto reconnects, and server list changing
type ZkPlus struct {
        pathPrefix  string
        zkConnector ZkConnector

        connectedConn zktest.ZkConnSupported
        connectedChan &lt;-chan zk.Event
        shouldQuit    chan chan struct{}
        askForConn    chan chan zktest.ZkConnSupported

        exposedChan chan zk.Event
}

var errInvalidPathPrefix = errors.New("invalid prefix path: Must being with /")
var errInvalidPathSuffix = errors.New("invalid prefix path: Must not end with /")

// EventChan that will see zookeeper events whos path is changed to this zk connection's
// namespace
func (z *ZkPlus) EventChan() &lt;-chan zk.Event <span class="cov8" title="1">{
        return z.exposedChan
}</span>

func whenI(cond bool, in &lt;-chan zk.Event) &lt;-chan zk.Event <span class="cov8" title="1">{
        if cond </span><span class="cov8" title="1">{
                return in
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func whenO(cond bool, out chan zk.Event) chan zk.Event <span class="cov8" title="1">{
        if cond </span><span class="cov8" title="1">{
                return out
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func whenAsk(cond bool, out chan chan zktest.ZkConnSupported) chan chan zktest.ZkConnSupported <span class="cov8" title="1">{
        if cond </span><span class="cov8" title="1">{
                return out
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func whenTimer(cond bool, duration time.Duration) &lt;-chan time.Time <span class="cov8" title="1">{
        if cond </span><span class="cov8" title="1">{
                return time.After(duration)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (z *ZkPlus) ensureRootPath(conn zktest.ZkConnSupported) error <span class="cov8" title="1">{
        parts := strings.Split(z.pathPrefix, "/")
        totalPath := ""
        for _, p := range parts </span><span class="cov8" title="1">{
                if p == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">totalPath = totalPath + "/" + p
                _, err := conn.Create(totalPath, []byte(""), 0, zk.WorldACL(zk.PermAll))
                if err != nil &amp;&amp; err != zk.ErrNodeExists </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (z *ZkPlus) eventLoop() <span class="cov8" title="1">{
        var haveEventToSend bool
        var eventToSend zk.Event
        delayForNewConn := time.Millisecond * 0
        for </span><span class="cov8" title="1">{
                select </span>{
                <span class="cov8" title="1">case eventToSend = &lt;-whenI(!haveEventToSend &amp;&amp; z.connectedChan != nil, z.connectedChan):
                        log.WithField("event", eventToSend).WithField("pre", z.pathPrefix).Debug("ZkPlus event")
                        if strings.HasPrefix(eventToSend.Path, z.pathPrefix) </span><span class="cov8" title="1">{
                                eventToSend.Path = eventToSend.Path[len(z.pathPrefix):]
                                if eventToSend.Path == "" </span><span class="cov8" title="1">{
                                        eventToSend.Path = "/"
                                }</span>
                        }
                        <span class="cov8" title="1">haveEventToSend = true
                        delayForNewConn = time.Millisecond * 0</span>
                <span class="cov8" title="1">case whenO(haveEventToSend, z.exposedChan) &lt;- eventToSend:
                        log.Debug("Send to exposed chan from zkplus")
                        haveEventToSend = false</span>
                <span class="cov8" title="1">case c := &lt;-whenAsk(z.connectedConn != nil, z.askForConn):
                        c &lt;- z.connectedConn</span>
                <span class="cov8" title="1">case &lt;-whenTimer(z.connectedConn == nil, delayForNewConn):
                        delayForNewConn = time.Millisecond * 100
                        z.setupConn()</span>
                <span class="cov8" title="1">case c := &lt;-z.shouldQuit:
                        z.onQuit(c)
                        return</span>
                }
        }
}

func (z *ZkPlus) onQuit(c chan struct{}) <span class="cov8" title="1">{
        c &lt;- struct{}{}
        if z.connectedConn != nil </span><span class="cov8" title="1">{
                z.connectedConn.Close()
                z.connectedConn = nil
        }</span>
        <span class="cov8" title="1">log.Info("Close on event loop")</span>
}

func (z *ZkPlus) setupConn() <span class="cov8" title="1">{
        c, e, err := z.zkConnector.Conn()
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">z.connectedConn = c
        z.connectedChan = e
        if err := z.ensureRootPath(c); err != nil </span><span class="cov8" title="1">{
                log.WithField("err", err).Warn("Unable to ensure root path")
                z.connectedConn.Close()
                z.connectedConn = nil
                z.connectedChan = nil
        }</span>
}

// Close this zk connection, blocking till the eventLoop() is finished.
func (z *ZkPlus) Close() <span class="cov8" title="1">{
        c := make(chan struct{})
        z.shouldQuit &lt;- c
        &lt;-c
        close(z.shouldQuit)
        close(z.exposedChan)
}</span>

func (z *ZkPlus) realPath(path string) string <span class="cov8" title="1">{
        if len(path) == 0 || path[0] != '/' </span><span class="cov8" title="1">{
                path = "/" + path
        }</span>
        <span class="cov8" title="1">finalPath := fmt.Sprintf("%s%s", z.pathPrefix, path)
        if finalPath != "/" &amp;&amp; finalPath[len(finalPath)-1] == '/' </span><span class="cov8" title="1">{
                finalPath = finalPath[0 : len(finalPath)-1]
        }</span>
        <span class="cov8" title="1">log.WithField("finalPath", finalPath).Debug("Final path!")
        return finalPath</span>
}

func (z *ZkPlus) blockOnConn() zktest.ZkConnSupported <span class="cov8" title="1">{
        c := make(chan zktest.ZkConnSupported)
        z.askForConn &lt;- c
        r := &lt;-c
        return r
}</span>

// Exists returns true if the path exists
func (z *ZkPlus) Exists(path string) (bool, *zk.Stat, error) <span class="cov8" title="1">{
        log.WithField("path", path).Debug("Exists")
        return z.blockOnConn().Exists(z.realPath(path))
}</span>

// ExistsW is like Exists but also sets a watch.  Note: We DO NOT change paths on the returned
// channel nor do we reconnect it.  Use the global channel instead
func (z *ZkPlus) ExistsW(path string) (bool, *zk.Stat, &lt;-chan zk.Event, error) <span class="cov8" title="1">{
        log.WithField("path", path).Debug("ExistsW")
        return z.blockOnConn().ExistsW(z.realPath(path))
}</span>

// Get the bytes of a zk path
func (z *ZkPlus) Get(path string) ([]byte, *zk.Stat, error) <span class="cov8" title="1">{
        log.WithField("path", path).Debug("Get")
        return z.blockOnConn().Get(z.realPath(path))
}</span>

// GetW is like Get, but also sets a watch
func (z *ZkPlus) GetW(path string) ([]byte, *zk.Stat, &lt;-chan zk.Event, error) <span class="cov8" title="1">{
        log.WithField("path", path).Debug("GetW")
        return z.blockOnConn().GetW(z.realPath(path))
}</span>

// Children gets children of a path
func (z *ZkPlus) Children(path string) ([]string, *zk.Stat, error) <span class="cov8" title="1">{
        log.WithField("path", z.realPath(path)).Debug("ChildrenW")
        return z.blockOnConn().Children(z.realPath(path))
}</span>

// ChildrenW is like children but also sets a watch
func (z *ZkPlus) ChildrenW(path string) ([]string, *zk.Stat, &lt;-chan zk.Event, error) <span class="cov8" title="1">{
        log.WithField("path", z.realPath(path)).Debug("ChildrenW")
        return z.blockOnConn().ChildrenW(z.realPath(path))
}</span>

// Delete a Zk node
func (z *ZkPlus) Delete(path string, version int32) error <span class="cov8" title="1">{
        log.WithField("path", path).Debug("Delete")
        return z.blockOnConn().Delete(z.realPath(path), version)
}</span>

// Create a Zk node
func (z *ZkPlus) Create(path string, data []byte, flags int32, acl []zk.ACL) (string, error) <span class="cov8" title="1">{
        log.WithField("path", path).Debug("Create")
        p, err := z.blockOnConn().Create(z.realPath(path), data, flags, acl)
        if strings.HasPrefix(p, z.pathPrefix) &amp;&amp; z.pathPrefix != "" </span><span class="cov8" title="1">{
                p = p[len(z.pathPrefix)+1:]
        }</span>
        <span class="cov8" title="1">return p, err</span>
}

// Set the data of a zk node
func (z *ZkPlus) Set(path string, data []byte, version int32) (*zk.Stat, error) <span class="cov8" title="1">{
        log.WithField("path", path).Debug("Set")
        return z.blockOnConn().Set(z.realPath(path), data, version)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
