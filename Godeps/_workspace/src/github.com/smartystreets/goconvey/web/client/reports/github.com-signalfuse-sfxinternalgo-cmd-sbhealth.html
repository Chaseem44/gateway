
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/signalfuse/sfxinternalgo/cmd/sbhealth/sbhealth.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package main

import (
        "flag"
        "time"
        "net/http"
        "net/url"
        "github.com/signalfx/golib/datapoint"
        "fmt"
        "log"
        "os"
        "encoding/json"
)

const version = "1.0.0"

func init() <span class="cov8" title="1">{
        flag.StringVar(&amp;instance.hostname, "hostname", "localhost", "Hostname to check")
        flag.IntVar(&amp;instance.port, "port", 6060, "Debug port")
        flag.Int64Var(&amp;instance.healthCount, "health_count", 10, "Healthchecks to require")
        flag.StringVar(&amp;instance.path, "path", "/debug/vars", "HTTP path for vars endpoint")
        flag.DurationVar(&amp;instance.uptime, "uptime", time.Second * 30, "Host uptime required")
        flag.DurationVar(&amp;instance.timeout, "timeout", time.Second * 5, "expvar timeout")
        flag.Int64Var(&amp;instance.minHealthCheckCount, "min_health", 10, "Minimum total number of health checks")
        flag.Int64Var(&amp;instance.minSessionCacheSize, "min_session", 3, "Minimum session cache size")
        flag.BoolVar(&amp;instance.showVersion, "version", false, "If true, print version and exit")
}</span>

type logable interface {
        Printf(format string, v ...interface{})
}

var _ logable = &amp;log.Logger{}

type SbHealth struct {
        hostname string
        port int
        healthCount int64
        path string
        uptime time.Duration
        timeout time.Duration
        minHealthCheckCount int64
        minSessionCacheSize int64
        showVersion bool

        log logable
        client http.Client
        osExit func(int)
}

var instance = SbHealth {
        log: log.New(os.Stderr, "", log.LstdFlags),
        osExit: os.Exit,
}

func main() <span class="cov8" title="1">{
        flag.Parse()
        instance.main()
}</span>

func (s *SbHealth) main() <span class="cov8" title="1">{
        if s.showVersion </span><span class="cov8" title="1">{
                fmt.Println(version)
                s.osExit(1)
        }</span>
        <span class="cov8" title="1">err := s.check()
        if err != nil </span><span class="cov8" title="1">{
                s.log.Printf("%s", err)
                s.osExit(1)
        }</span>
}

type PointsArray []datapoint.Datapoint

type varsResp struct {
        Points PointsArray `json:"datapoints"`
        Cmdline []string    `json:"cmdline"`
}

func (p PointsArray) datapoint(metric string) *int64 <span class="cov8" title="1">{
        for _, dp := range p </span><span class="cov8" title="1">{
                if dp.Metric == metric </span><span class="cov8" title="1">{
                        if iv, ok := dp.Value.(datapoint.IntValue); ok </span><span class="cov8" title="1">{
                                i := iv.Int()
                                return &amp;i
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *SbHealth) check() error <span class="cov8" title="1">{
        url := url.URL{
                Scheme: "http",
                Host: fmt.Sprintf("%s:%d", s.hostname, s.port),
                Path: s.path,
        }
        s.client.Timeout = s.timeout
        resp, err := s.client.Get(url.String())
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Unable to fetch stats URL: %s", err)
        }</span>
        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return fmt.Errorf("Unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">var r varsResp
        if err := json.NewDecoder(resp.Body).Decode(&amp;r); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Invalid response body: %s", err)
        }</span>
        <span class="cov8" title="1">s.log.Printf("Total number of points: %d", len(r.Points))
        totalHealthChecks := r.Points.datapoint("total_health_checks")
        if totalHealthChecks == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Unable to find metric total_health_checks")
        }</span>
        <span class="cov8" title="1">if *totalHealthChecks &lt; s.minHealthCheckCount </span><span class="cov8" title="1">{
                return fmt.Errorf("Health check count %d less than required %d", *totalHealthChecks, s.minHealthCheckCount)
        }</span>
        <span class="cov8" title="1">sessionCacheSize := r.Points.datapoint("SessionCacheSize")
        if sessionCacheSize == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Unable to find metric SessionCacheSize")
        }</span>
        <span class="cov8" title="1">if *sessionCacheSize &lt; s.minSessionCacheSize </span><span class="cov8" title="1">{
                return fmt.Errorf("Session cache size %d less than required %d", *sessionCacheSize, s.minSessionCacheSize)
        }</span>
        <span class="cov8" title="1">s.log.Printf("Health checks: %d SessionCacheSize: %d", *totalHealthChecks, *sessionCacheSize)
        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
