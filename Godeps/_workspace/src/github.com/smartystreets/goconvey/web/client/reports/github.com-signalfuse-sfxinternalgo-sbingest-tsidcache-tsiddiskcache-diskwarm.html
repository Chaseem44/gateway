
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/signalfuse/sfxinternalgo/sbingest/tsidcache/tsiddiskcache/diskwarm/diskwarm.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package diskwarm

import (
        "bytes"
        "encoding/base64"
        "encoding/binary"
        "encoding/json"
        "errors"
        "strings"
        "time"

        "github.com/Sirupsen/logrus"
        "github.com/olivere/elastic"
        "github.com/signalfuse/sfxinternalgo/sbingest/tsidcache/tsiddiskcache"
        "github.com/signalfx/golib/logherd"
)

var log *logrus.Logger

func init() <span class="cov8" title="1">{
        log = logherd.New()
}</span>

// WarmCache will search elastic search for active MTS and save them into a database
type WarmCache struct {
        Esclient   *elastic.Client
        IndexName  string
        ScrollSize int
        KeepAlive  time.Duration
        StoreInto  StoreInto
        FetchLimit int
}

// StoreInto is the minimal interface that WarmCache stores ES results into
type StoreInto interface {
        WriteResult(buf *bytes.Buffer, res map[tsiddiskcache.Encodeable]int64) error
        MarkValidAtTimestamp(now time.Time) error
}

var _ StoreInto = &amp;tsiddiskcache.DiskCache{}

// ElasticSearchObjectType are the object types we fetch from elastic search
const ElasticSearchObjectType = "object"

// Warm the cache StoreInto with results from ES
func (w *WarmCache) Warm() error <span class="cov8" title="1">{
        if w.Esclient == nil </span><span class="cov8" title="1">{
                // Is this an error or not?  Kind of ambiguous.
                log.Warn("Skipping cache warm.  Unable to find valid elastic search client")
                return nil
        }</span>
        <span class="cov8" title="1">log.Info("Starting cache warm")
        query := elastic.NewQueryStringQuery("sf_type:MetricTimeSeries AND sf_isActive:true")
        scrollQuery := w.Esclient.Scroll(w.IndexName).Type(ElasticSearchObjectType).KeepAlive("1m").Query(query).Size(w.ScrollSize)
        page, err := scrollQuery.GetFirstPage()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">scrollQuery.ScrollId(page.ScrollId)
        page, err = scrollQuery.GetNextPage()
        if err == elastic.EOS </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">buf := new(bytes.Buffer)
        totalSaved := 0
        for len(page.Hits.Hits) &gt; 0 </span><span class="cov8" title="1">{
                log.Infof("Warming hit: At: %d Size: %d Total: %d", totalSaved, len(page.Hits.Hits), page.Hits.TotalHits)
                scrollQuery.ScrollId(page.ScrollId)
                toWrite := extractHits(page.Hits.Hits)
                w.StoreInto.WriteResult(buf, toWrite)
                totalSaved += len(toWrite)
                if totalSaved &gt;= w.FetchLimit &amp;&amp; w.FetchLimit != 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">page, err = scrollQuery.GetNextPage()
                if err == elastic.EOS </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">w.StoreInto.MarkValidAtTimestamp(time.Now())
        return nil</span>
}

func extractHits(hits []*elastic.SearchHit) map[tsiddiskcache.Encodeable]int64 <span class="cov8" title="1">{
        toWrite := make(map[tsiddiskcache.Encodeable]int64)
        for _, h := range hits </span><span class="cov8" title="1">{
                sourceBytes, _ := h.Source.MarshalJSON()
                diskKey, err := getKey(sourceBytes)
                if err != nil </span><span class="cov8" title="1">{
                        log.WithField("err", err).WithField("hit", h).WithField("bytes", string(sourceBytes)).Warn("Invalid source in cache warm")
                        continue</span>
                }
                <span class="cov8" title="1">tsid, err := idFromStr(base64.StdEncoding, h.Id)
                if err != nil </span><span class="cov8" title="1">{
                        log.WithField("err", err).Warn("Invalid ID in cache warm")
                        continue</span>
                }
                <span class="cov8" title="1">toWrite[diskKey] = tsid</span>
        }
        <span class="cov8" title="1">return toWrite</span>
}

// ErrNoKeyInObject is returned when sf_key is not in the ES object
var ErrNoKeyInObject = errors.New("no sf_key found in object")

// ErrSourceContentNotValid is a generic error meaning the ES objec tisn't valid
var ErrSourceContentNotValid = errors.New("source object not valid")

// ErrDimensionNotInObject means ES points to an object who's key isn't found
var ErrDimensionNotInObject = errors.New("dimension value not found")

// ErrNoMetric means the ES object did not have a sf_metric defined
var ErrNoMetric = errors.New("metric not found in key")

func getKey(source []byte) (*tsiddiskcache.DiskKey, error) <span class="cov8" title="1">{
        // map[string]string, int64
        sourceContents := make(map[string]interface{})
        if err := json.Unmarshal(source, &amp;sourceContents); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">orgID, err := getID(sourceContents, "sf_organizationID")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">keys, exists := sourceContents["sf_key"]
        if !exists </span><span class="cov8" title="1">{
                return nil, ErrNoKeyInObject
        }</span>
        <span class="cov8" title="1">keyArray, validContent := keys.([]interface{})
        if !validContent </span><span class="cov8" title="1">{
                return nil, ErrSourceContentNotValid
        }</span>
        <span class="cov8" title="1">dimensions := make(map[string]string)
        for _, keyItem := range keyArray </span><span class="cov8" title="1">{
                key, valid := keyItem.(string)
                if !valid </span><span class="cov8" title="1">{
                        return nil, ErrSourceContentNotValid
                }</span>
                <span class="cov8" title="1">value, exists := sourceContents[key]
                if !exists </span><span class="cov8" title="1">{
                        return nil, ErrDimensionNotInObject
                }</span>
                <span class="cov8" title="1">valueStr, validContent := value.(string)
                if !validContent </span><span class="cov8" title="1">{
                        return nil, ErrSourceContentNotValid
                }</span>
                <span class="cov8" title="1">dimensions[key] = valueStr</span>
        }
        <span class="cov8" title="1">metric, exists := dimensions["sf_metric"]
        if !exists </span><span class="cov8" title="1">{
                return nil, ErrNoMetric
        }</span>
        <span class="cov8" title="1">delete(dimensions, "sf_metric")
        return &amp;tsiddiskcache.DiskKey{
                Metric:     metric,
                Dimensions: dimensions,
                Org:        orgID,
        }, nil</span>
}

// ErrNotInMap means we tried to look up an ID in a map, but the ID index wasn't found
var ErrNotInMap = errors.New("key not in map")

// ErrInvalidOrgID means the ID in the map wasn't a valid int64
var ErrInvalidOrgID = errors.New("invalid orgID")

func getID(m map[string]interface{}, key string) (int64, error) <span class="cov8" title="1">{
        orgIDInterface, ok := m[key]
        if !ok </span><span class="cov8" title="1">{
                return 0, ErrNotInMap
        }</span>
        <span class="cov8" title="1">orgIDStr, ok := orgIDInterface.(string)
        if !ok </span><span class="cov8" title="1">{
                return 0, ErrInvalidOrgID
        }</span>
        <span class="cov8" title="1">return idFromStr(base64.URLEncoding, orgIDStr)</span>
}

func idFromStr(encoding *base64.Encoding, idStr string) (int64, error) <span class="cov8" title="1">{
        //        bytes, err := base64.StdEncoding.DecodeString(padEncode(idStr))
        bytes, err := encoding.DecodeString(padEncode(idStr))
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">if len(bytes) &lt; 7 </span><span class="cov8" title="1">{
                return 0, ErrInvalidOrgID
        }</span>
        <span class="cov8" title="1">return int64(binary.BigEndian.Uint64(bytes)), nil</span>
}

func padEncode(str string) string <span class="cov8" title="1">{
        if len(str)%4 != 0 </span><span class="cov8" title="1">{
                str += strings.Repeat("=", 4-(len(str)%4))
        }</span>
        <span class="cov8" title="1">return str</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
