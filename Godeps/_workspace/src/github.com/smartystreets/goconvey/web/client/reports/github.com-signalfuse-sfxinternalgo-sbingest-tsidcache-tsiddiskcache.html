
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/signalfuse/sfxinternalgo/sbingest/tsidcache/tsiddiskcache/diskcache.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package tsiddiskcache

import (
        "bytes"
        "encoding/binary"
        "errors"
        "os"
        "sort"
        "time"

        "net/http"
        "strconv"

        "fmt"

        "path/filepath"

        "sync"

        "strings"

        "sync/atomic"

        "github.com/Sirupsen/logrus"
        "github.com/boltdb/bolt"
        "github.com/boltdb/boltd"
        "github.com/golang/protobuf/proto"
        "github.com/signalfuse/sfxinternalgo/sbingest/datum"
        "github.com/signalfuse/sfxinternalgo/sbingest/tsidcache/tsiddiskcache/datumhash"
        "github.com/signalfuse/sfxinternalgo/sbingest/tsidcache/tsiddiskcache/proto/compact_proto"
        "github.com/signalfuse/sfxinternalgo/sfxthrift/thrift/datamodel"
        "github.com/signalfx/golib/boltcycle"
        "github.com/signalfx/golib/datapoint"
        "github.com/signalfx/golib/distconf"
        "github.com/signalfx/golib/logherd"
        "github.com/signalfx/golib/sfxclient"
        "github.com/signalfx/golib/timekeeper"
        "golang.org/x/net/context"
)

var log *logrus.Logger

func init() <span class="cov8" title="1">{
        log = logherd.New()
}</span>

type stringPairs []*compact_proto.CacheItem_Dimension

func (s stringPairs) Len() int <span class="cov8" title="1">{
        return len(s)
}</span>

func (s stringPairs) Less(i, j int) bool <span class="cov8" title="1">{
        return *s[i].Key &lt; *s[j].Key
}</span>

func (s stringPairs) Swap(i, j int) <span class="cov8" title="1">{
        s[i], s[j] = s[j], s[i]
}</span>

var errStringKeyOutOfOrder = errors.New("string keys out of order")

// CycleDB is the interface we use for the V2 database
type CycleDB interface {
        Write(towrite []boltcycle.KvPair) error
        AsyncWrite(ctx context.Context, towrite []boltcycle.KvPair)
        Delete(keys [][]byte) ([]bool, error)
        Read(toread [][]byte) ([][]byte, error)
        CycleNodes() error
        Stats() boltcycle.Stats
}

// DiskCache can store TSID for datum on disk, allowing faster retrieval than going to network
type DiskCache struct {
        filename       string
        tsidBucket     []byte
        metadataBucket []byte
        db             *bolt.DB
        byteEncoder    binary.ByteOrder
        cycleDB        CycleDB

        useOldDB *distconf.Bool

        rotationLoop chan struct{}
        diskStatLoop chan struct{}
        client       *sfxclient.Reporter

        stats struct {
                newDBReadHits    int64
                newDBReadMisses  int64
                copyBackFailures int64
                newDBRecopy      int64
                cycleAttempts    int64
                cycleFailures    int64
        }
}

// Encodeable is used to convert datum and mts into a common []byte format for on disk storage.
type Encodeable interface {
        EncodeOld(buf *bytes.Buffer) error
        DecodeOld(buf []byte) (err error)

        EncodeCycle(buf *bytes.Buffer) error
}

// DiskKey is the common interface for encoding data for the on disk cache
type DiskKey struct {
        Metric     string
        Dimensions map[string]string
        Org        int64
}

func (e *DiskKey) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s %s %d", e.Metric, e.Dimensions, e.Org)
}</span>

// FromDatum creates a disk key that is used for the datum's TSID lookup
func (e *DiskKey) FromDatum(dat *datum.Datum) *DiskKey <span class="cov8" title="1">{
        e.Metric = dat.Metric
        e.Dimensions = dat.Dimensions
        e.Org = dat.OrgID
        return e
}</span>

// FromMTSD creates a disk key that is used for the MTSD lookup
func (e *DiskKey) FromMTSD(mts *datamodel.MetricTimeSeriesDetails) *DiskKey <span class="cov8" title="1">{
        e.Metric = mts.Metric
        e.Dimensions = mts.Dimensions
        e.Org = mts.OrganizationId.Id
        return e
}</span>

// FromThrift creates a writable tsid result from a thrift result
func FromThrift(res *datamodel.CreateManyResult_) map[Encodeable]int64 <span class="cov8" title="1">{
        w := make(map[Encodeable]int64, len(res.MetricTimeSeriesResultObjs))
        for mtsd, resObj := range res.MetricTimeSeriesResultObjs </span><span class="cov8" title="1">{
                if resObj.Status == datamodel.CreateManyResultStatus_CREATED || resObj.Status == datamodel.CreateManyResultStatus_FETCHED </span><span class="cov8" title="1">{
                        w[(&amp;DiskKey{}).FromMTSD(mtsd)] = resObj.Mts.Id.Id
                }</span>
        }
        <span class="cov8" title="1">return w</span>
}

// DecodeOld will use the old algorithym to decode the buf into this DiskKey object
func (e *DiskKey) DecodeOld(buf []byte) error <span class="cov8" title="1">{
        var ci compact_proto.CacheItem
        err := proto.Unmarshal(buf, &amp;ci)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">dims := make(map[string]string)
        previousString := ""
        for _, d := range ci.GetDims() </span><span class="cov8" title="1">{
                if d.GetKey() &lt;= previousString </span><span class="cov8" title="1">{
                        return errStringKeyOutOfOrder
                }</span>
                <span class="cov8" title="1">dims[d.GetKey()] = d.GetValue()
                previousString = d.GetKey()</span>
        }
        <span class="cov8" title="1">e.Metric = ci.GetMetric()
        e.Dimensions = dims
        e.Org = ci.GetOrgId()
        return nil</span>
}

// ErrInvalidDiskKey is returned when one tries to encde a DiskKey into a buffer, but the object
// itself is invalid
var ErrInvalidDiskKey = errors.New("cannot encode invalid disk key")

var protocache = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                return proto.NewBuffer(nil)
        }</span>,
}

var compactProtoCache = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                return &amp;compact_proto.CacheItem{}
        }</span>,
}

var hasherPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                x := datumhash.InitDatumHasher()
                return &amp;x
        }</span>,
}

// EncodeCycle will use the new cycle encoding for the DiskKey into buffer
func (e *DiskKey) EncodeCycle(buf *bytes.Buffer) error <span class="cov8" title="1">{
        h := hasherPool.Get().(*datumhash.SHA256DatumHasher)
        h.Sum(buf, &amp;datum.Datum{
                Datapoint: &amp;datapoint.Datapoint{
                        Metric:     e.Metric,
                        Dimensions: e.Dimensions,
                },
                OrgID: e.Org,
        })
        hasherPool.Put(h)
        return nil
}</span>

func createDims(ci *compact_proto.CacheItem, finalLen int) <span class="cov8" title="1">{
        if ci.Dims == nil </span><span class="cov8" title="1">{
                ci.Dims = make([]*compact_proto.CacheItem_Dimension, finalLen)
        }</span><span class="cov8" title="1"> else if finalLen &lt;= len(ci.Dims) </span><span class="cov8" title="1">{
                ci.Dims = ci.Dims[0:finalLen]
        }</span><span class="cov8" title="1"> else {
                extra := finalLen - len(ci.Dims)
                ci.Dims = append(ci.Dims, make([]*compact_proto.CacheItem_Dimension, extra)...)
        }</span>
}

// EncodeOld will use the old algorithm to encode the buf into this DiskKey
func (e *DiskKey) EncodeOld(buf *bytes.Buffer) error <span class="cov8" title="1">{
        if e.Metric == "" || e.Org == 0 </span><span class="cov8" title="1">{
                return ErrInvalidDiskKey
        }</span>
        <span class="cov8" title="1">ci := compactProtoCache.Get().(*compact_proto.CacheItem)
        ci.OrgId = &amp;e.Org
        ci.Metric = &amp;e.Metric
        createDims(ci, len(e.Dimensions))

        i := 0
        for k, v := range e.Dimensions </span><span class="cov8" title="1">{
                if ci.Dims[i] == nil </span><span class="cov8" title="1">{
                        ci.Dims[i] = &amp;compact_proto.CacheItem_Dimension{}
                }</span>
                <span class="cov8" title="1">ci.Dims[i].Key = proto.String(k)
                ci.Dims[i].Value = proto.String(v)
                i++</span>
        }
        <span class="cov8" title="1">sort.Sort(stringPairs(ci.Dims))

        pc := protocache.Get().(*proto.Buffer)
        pc.Reset()
        err := pc.Marshal(ci)
        if err == nil </span><span class="cov8" title="1">{
                buf.Write(pc.Bytes())
        }</span>
        <span class="cov8" title="1">protocache.Put(pc)
        compactProtoCache.Put(ci)
        return nil</span>
}

var _ Encodeable = &amp;DiskKey{}

const defaultTsidBucketName = "t"
const metadataBucketName = "m"

// DiskCacheConfig controls loading the on disk cache of tsids
type DiskCacheConfig struct {
        DataDir         string
        DiskTimeout     time.Duration
        DiskStatsDelay  *distconf.Duration
        CycleDelay      *distconf.Duration
        UseOldDB        *distconf.Bool
        DBFilename      string
        TsidBucketName  string
        CycleCount      int64
        VerifyOnLoad    bool
        SkipRename      bool
        OsStat          func(filename string) (os.FileInfo, error)
        BoltInit        func(db *bolt.DB, config ...boltcycle.DBConfiguration) (*boltcycle.CycleDB, error)
        OsMkdirAll      func(string, os.FileMode) error
        OsRename        func(string, string) error
        SleepTimeKeeper timekeeper.TimeKeeper
}

// Load the cache config from distconf
func (d *DiskCacheConfig) Load(conf *distconf.Config) <span class="cov8" title="1">{
        d.DataDir = conf.Str("dataDir", os.TempDir()).Get()
        d.SkipRename = false
        d.DiskTimeout = conf.Duration("tsidcache.timeout", time.Second).Get()
        d.CycleCount = conf.Int("tsidcache.cycle_count", 3).Get()
        d.DiskStatsDelay = conf.Duration("tsidcache.disk_stats_delay", time.Second*30)
        d.SleepTimeKeeper = timekeeper.RealTime{}
        d.DBFilename = conf.Str("dbfile.name", "tsidcache.bolt").Get()
        d.VerifyOnLoad = conf.Bool("dbfile.verify_on_load", true).Get()
        d.TsidBucketName = conf.Str("dbfile.tsidbucket.name", defaultTsidBucketName).Get()
        d.CycleDelay = conf.Duration("tsidcache.cycle_delay", time.Hour*24)
        d.UseOldDB = conf.Bool("tsidcache.use_old_db", true)
        d.BoltInit = boltcycle.New
        d.OsStat = os.Stat
        d.OsMkdirAll = os.MkdirAll
        d.OsRename = os.Rename
}</span>

func (d *DiskCacheConfig) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("DataDir=%s DiskTimeout=%s DBFilename=%s TsidBucketName=%s", d.DataDir, d.DiskTimeout, d.DBFilename, d.TsidBucketName)
}</span>

// FullFilepath is a convinence method that joins the directory and filename set in config into
// the actual path we write the TSID to
func (d *DiskCacheConfig) FullFilepath() string <span class="cov8" title="1">{
        return filepath.Join(d.DataDir, d.DBFilename)
}</span>

func verifyDirectory(config *DiskCacheConfig) error <span class="cov8" title="1">{
        log.WithField("dataDir", config.DataDir).Info("Verification of data directory")
        _, err := config.OsStat(config.DataDir)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                err = config.OsMkdirAll(config.DataDir, 0700)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ErrDiskPathIsDirectory is returned whenever you try to create a disk cache with a filename that
// is an existing directory
var ErrDiskPathIsDirectory = errors.New("on disk final path is a directory which is invalid")

// NewDiskCache creates a new on disk cache, trying to verify that it is valid and the directory
// exists for it.
func NewDiskCache(config *DiskCacheConfig, client *sfxclient.Reporter) (*DiskCache, error) <span class="cov8" title="1">{
        log.WithField("config", config).Info("Setting up disk cache")
        defer log.Info("Done setting up disk cache")
        err := verifyDirectory(config)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">dbFileName := config.FullFilepath()
        log.WithField("dbFileName", dbFileName).Info("Final filename found")
        s, err := config.OsStat(dbFileName)
        if err != nil </span><span class="cov8" title="1">{
                log.WithField("s", s).WithField("err", err).Error("Unable to stat db filename.  This should only happen on fresh servers!")
        }</span>
        <span class="cov8" title="1">if err == nil &amp;&amp; s.IsDir() </span><span class="cov8" title="1">{
                return nil, ErrDiskPathIsDirectory
        }</span>
        <span class="cov8" title="1">disk, err := newDiskCache(config, client)
        if err != nil &amp;&amp; !config.SkipRename </span><span class="cov8" title="1">{
                log.WithField("dbFileName", dbFileName).WithField("err", err).Info("Unable to verify database.  You may need to delete the dbfile.  I will move it for you and try again")
                log.WithField("err", config.OsRename(dbFileName, dbFileName+".backup")).Info("Moved database to backup file")
                disk, err = newDiskCache(config, client)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return disk, nil</span>
}

func openDb(config *DiskCacheConfig) (*bolt.DB, error) <span class="cov8" title="1">{
        return bolt.Open(config.FullFilepath(), os.FileMode(0666), &amp;bolt.Options{
                Timeout: config.DiskTimeout,
        })
}</span>

func checkErrorChan(ch &lt;-chan error) error <span class="cov8" title="1">{
        for err := range ch </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        // This error happens somewhat with bolt.  It's unfortunant, but not worth redownloading
                        // the database
                        if strings.Contains(err.Error(), "unreachable unfreed") </span><span class="cov8" title="1">{
                                continue</span>
                        }
                }
                <span class="cov8" title="1">return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func newDiskCache(config *DiskCacheConfig, client *sfxclient.Reporter) (*DiskCache, error) <span class="cov8" title="1">{
        db, err := openDb(config)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ret := &amp;DiskCache{
                filename:       config.FullFilepath(),
                tsidBucket:     []byte(config.TsidBucketName),
                metadataBucket: []byte(metadataBucketName),
                db:             db,
                diskStatLoop:   make(chan struct{}),
                rotationLoop:   make(chan struct{}),
                byteEncoder:    binary.BigEndian,
                useOldDB:       config.UseOldDB,
        }
        err = ret.db.Update(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                bucketNames := [][]byte{ret.tsidBucket, ret.metadataBucket}
                for _, bucketName := range bucketNames </span><span class="cov8" title="1">{
                        _, err := tx.CreateBucketIfNotExists(bucketName)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">log.Info("Running database Check()")
                defer log.Info("Done running database Check()")
                return checkErrorChan(tx.Check())</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if ret.cycleDB, err = config.BoltInit(db, boltcycle.CycleLen(int(config.CycleCount))); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if config.VerifyOnLoad </span><span class="cov8" title="1">{
                if err = ret.VerifyDatabase(); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if client != nil </span><span class="cov8" title="1">{
                ret.setupStatReporting(client, config.DiskStatsDelay, config.SleepTimeKeeper)
        }</span>
        <span class="cov8" title="1">go ret.startCacheRotating(config.SleepTimeKeeper, config.CycleDelay)
        return ret, nil</span>
}

type atomicStats struct {
        stats *Stats
        mu    sync.Mutex
}

func (a *atomicStats) Store(s *Stats) <span class="cov8" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()
        a.stats = s
}</span>

func (a *atomicStats) LoadAndClear() *Stats <span class="cov8" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()
        ret := a.stats
        a.stats = nil
        return ret
}</span>

func (dc *DiskCache) startCacheRotating(keeper timekeeper.TimeKeeper, cycleDelay *distconf.Duration) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                <span class="cov8" title="1">case &lt;-dc.rotationLoop:
                        return</span>
                <span class="cov8" title="1">case &lt;-keeper.After(cycleDelay.Get()):
                        atomic.AddInt64(&amp;dc.stats.cycleAttempts, 1)
                        log.Info("Rotating cache")
                        if err := dc.cycleDB.CycleNodes(); err != nil </span><span class="cov8" title="1">{
                                atomic.AddInt64(&amp;dc.stats.cycleFailures, 1)
                                log.WithField("err", err).Warn("Unable to cycle nodes")
                        }</span>
                }
        }
}

func (dc *DiskCache) setupStatReporting(client *sfxclient.Reporter, statsDelay *distconf.Duration, keeper timekeeper.TimeKeeper) <span class="cov8" title="1">{
        dc.client = client
        var atomicStatsVal atomicStats
        if statsHere, err := dc.Stats(); err == nil </span><span class="cov8" title="1">{
                atomicStatsVal.Store(&amp;statsHere)
        }</span>
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        <span class="cov8" title="1">case &lt;-dc.diskStatLoop:
                                return</span>
                        <span class="cov8" title="1">case &lt;-keeper.After(statsDelay.Get()):
                                if statsHere, err := dc.Stats(); err == nil </span><span class="cov8" title="1">{
                                        atomicStatsVal.Store(&amp;statsHere)
                                }</span>
                        }
                }
        }()
        <span class="cov8" title="1">dims := map[string]string{
                "instance": "disk-tsidcache",
        }
        client.Cumulative("NewDBReadHits", sfxclient.Int(&amp;dc.stats.newDBReadHits))
        client.Cumulative("NewDBReadMisses", sfxclient.Int(&amp;dc.stats.newDBReadMisses))
        client.Cumulative("NewDBRecopy", sfxclient.Int(&amp;dc.stats.newDBRecopy))
        client.Cumulative("CycleAttempts", sfxclient.Int(&amp;dc.stats.cycleAttempts))
        client.Cumulative("CycleFailures", sfxclient.Int(&amp;dc.stats.cycleFailures))
        client.DirectDatapointCallback(func(defaultDims map[string]string) []*datapoint.Datapoint </span><span class="cov8" title="1">{
                stats := atomicStatsVal.LoadAndClear()
                if stats == nil </span><span class="cov8" title="1">{
                        return []*datapoint.Datapoint{}
                }</span>

                <span class="cov8" title="1">dimsToAdd := make(map[string]string, len(dims)+len(defaultDims))
                for k, v := range defaultDims </span><span class="cov8" title="1">{
                        dimsToAdd[k] = v
                }</span>
                <span class="cov8" title="1">for k, v := range dims </span><span class="cov8" title="1">{
                        dimsToAdd[k] = v
                }</span>

                <span class="cov8" title="1">now := time.Now()
                return []*datapoint.Datapoint{
                        datapoint.New("FreePageN", dimsToAdd, datapoint.NewIntValue(int64(stats.DbStats.FreePageN)), datapoint.Counter, now),
                        datapoint.New("PendingPageN", dimsToAdd, datapoint.NewIntValue(int64(stats.DbStats.PendingPageN)), datapoint.Counter, now),
                        datapoint.New("FreeAlloc", dimsToAdd, datapoint.NewIntValue(int64(stats.DbStats.FreeAlloc)), datapoint.Counter, now),
                        datapoint.New("FreelistInuse", dimsToAdd, datapoint.NewIntValue(int64(stats.DbStats.FreelistInuse)), datapoint.Counter, now),
                        datapoint.New("TxN", dimsToAdd, datapoint.NewIntValue(int64(stats.DbStats.TxN)), datapoint.Counter, now),
                        datapoint.New("OpenTxN", dimsToAdd, datapoint.NewIntValue(int64(stats.DbStats.OpenTxN)), datapoint.Gauge, now),

                        datapoint.New("PageCount", dimsToAdd, datapoint.NewIntValue(int64(stats.DbStats.TxStats.PageCount)), datapoint.Counter, now),
                        datapoint.New("PageAlloc", dimsToAdd, datapoint.NewIntValue(int64(stats.DbStats.TxStats.PageAlloc)), datapoint.Counter, now),
                        datapoint.New("CursorCount", dimsToAdd, datapoint.NewIntValue(int64(stats.DbStats.TxStats.CursorCount)), datapoint.Counter, now),
                        datapoint.New("NodeCount", dimsToAdd, datapoint.NewIntValue(int64(stats.DbStats.TxStats.NodeCount)), datapoint.Counter, now),
                        datapoint.New("NodeDeref", dimsToAdd, datapoint.NewIntValue(int64(stats.DbStats.TxStats.NodeDeref)), datapoint.Counter, now),
                        datapoint.New("Rebalance", dimsToAdd, datapoint.NewIntValue(int64(stats.DbStats.TxStats.Rebalance)), datapoint.Counter, now),
                        datapoint.New("Split", dimsToAdd, datapoint.NewIntValue(int64(stats.DbStats.TxStats.Split)), datapoint.Counter, now),
                        datapoint.New("Write", dimsToAdd, datapoint.NewIntValue(int64(stats.DbStats.TxStats.Write)), datapoint.Counter, now),

                        datapoint.New("BranchPageN", dimsToAdd, datapoint.NewIntValue(int64(stats.BucketStats.BranchPageN)), datapoint.Gauge, now),
                        datapoint.New("BranchOverflowN", dimsToAdd, datapoint.NewIntValue(int64(stats.BucketStats.BranchOverflowN)), datapoint.Gauge, now),
                        datapoint.New("LeafPageN", dimsToAdd, datapoint.NewIntValue(int64(stats.BucketStats.LeafPageN)), datapoint.Gauge, now),
                        datapoint.New("LeafOverflowN", dimsToAdd, datapoint.NewIntValue(int64(stats.BucketStats.LeafOverflowN)), datapoint.Gauge, now),
                        datapoint.New("KeyN", dimsToAdd, datapoint.NewIntValue(int64(stats.BucketStats.KeyN)), datapoint.Gauge, now),
                        datapoint.New("Depth", dimsToAdd, datapoint.NewIntValue(int64(stats.BucketStats.Depth)), datapoint.Gauge, now),
                        datapoint.New("BranchAlloc", dimsToAdd, datapoint.NewIntValue(int64(stats.BucketStats.BranchAlloc)), datapoint.Gauge, now),
                        datapoint.New("BranchInuse", dimsToAdd, datapoint.NewIntValue(int64(stats.BucketStats.BranchInuse)), datapoint.Gauge, now),
                        datapoint.New("LeafAlloc", dimsToAdd, datapoint.NewIntValue(int64(stats.BucketStats.LeafAlloc)), datapoint.Gauge, now),
                        datapoint.New("BranchInuse", dimsToAdd, datapoint.NewIntValue(int64(stats.BucketStats.BranchInuse)), datapoint.Gauge, now),
                        datapoint.New("LeafAlloc", dimsToAdd, datapoint.NewIntValue(int64(stats.BucketStats.LeafAlloc)), datapoint.Gauge, now),
                        datapoint.New("LeafInuse", dimsToAdd, datapoint.NewIntValue(int64(stats.BucketStats.LeafInuse)), datapoint.Gauge, now),
                        datapoint.New("BucketN", dimsToAdd, datapoint.NewIntValue(int64(stats.BucketStats.BucketN)), datapoint.Gauge, now),
                        datapoint.New("InlineBucketN", dimsToAdd, datapoint.NewIntValue(int64(stats.BucketStats.InlineBucketN)), datapoint.Gauge, now),
                        datapoint.New("InlineBucketInuse", dimsToAdd, datapoint.NewIntValue(int64(stats.BucketStats.InlineBucketInuse)), datapoint.Gauge, now),
                        datapoint.New("DbSize_bytes", dimsToAdd, datapoint.NewIntValue(stats.FileSize), datapoint.Gauge, now),
                }</span>
        })
}

var errInvalidKeyLength = errors.New("invalid int64 length in database")
var errInvalidTsid = errors.New("the TSID not valid in database")
var errSameTsidTwice = errors.New("found the same tsid twice in the database")

// VerifyDatabase will return nil if the database is valid
func (dc *DiskCache) VerifyDatabase() error <span class="cov8" title="1">{
        log.Info("VerifyDatabase() -&gt; ")
        defer log.Info("&lt;- VerifyDatabase()")
        return dc.db.View(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                bucket := tx.Bucket(dc.tsidBucket)
                if bucket == nil </span><span class="cov8" title="1">{
                        return errBucketDoesNotExist
                }</span>
                <span class="cov8" title="1">return bucket.ForEach(bucketValidation(dc.byteEncoder))</span>
        })
}

const validAtKeyName = "ok_at"

var errKeyDoesNotExist = errors.New("key does not exist in bucket")

// MarkValidAtTimestamp updates the database to signal that it is valid and stable at a time so
// we can trust it if we restart shortly
func (dc *DiskCache) MarkValidAtTimestamp(now time.Time) error <span class="cov8" title="1">{
        return dc.db.Update(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                bucket := tx.Bucket(dc.metadataBucket)
                if bucket == nil </span><span class="cov8" title="1">{
                        return errBucketDoesNotExist
                }</span>
                <span class="cov8" title="1">nowNs := now.UnixNano()
                return bucket.Put([]byte(validAtKeyName), []byte(strconv.FormatInt(nowNs, 10)))</span>
        })
}

// ValidAtTimestamp returns the last marked valid timestamp of this database
func (dc *DiskCache) ValidAtTimestamp() (t time.Time, err error) <span class="cov8" title="1">{
        timeNs := int64(0)
        err = dc.db.View(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                bucket := tx.Bucket(dc.metadataBucket)
                if bucket == nil </span><span class="cov8" title="1">{
                        return errBucketDoesNotExist
                }</span>
                <span class="cov8" title="1">b := bucket.Get([]byte(validAtKeyName))
                if b == nil </span><span class="cov8" title="1">{
                        return errKeyDoesNotExist
                }</span>
                <span class="cov8" title="1">timeNs, err = strconv.ParseInt(string(b), 10, 64)
                return err</span>
        })
        <span class="cov8" title="1">return time.Unix(0, timeNs), err</span>
}

func bucketValidation(byteEncoder binary.ByteOrder) func(k, v []byte) error <span class="cov8" title="1">{
        inverseMap := make(map[int64]struct{})

        key := &amp;DiskKey{}
        return func(k, v []byte) error </span><span class="cov8" title="1">{
                err := key.DecodeOld(k)
                if err != nil </span><span class="cov8" title="1">{
                        log.WithField("err", err).Info("Bad encoding")
                        return err
                }</span>

                <span class="cov8" title="1">if len(v) != 8 </span><span class="cov8" title="1">{
                        return errInvalidKeyLength
                }</span>
                <span class="cov8" title="1">tsid := int64(byteEncoder.Uint64(v))
                if tsid &lt;= 0 </span><span class="cov8" title="1">{
                        return errInvalidTsid
                }</span>

                <span class="cov8" title="1">_, existing := inverseMap[tsid]
                if existing </span><span class="cov8" title="1">{
                        return errSameTsidTwice
                }</span>
                <span class="cov8" title="1">inverseMap[tsid] = struct{}{}
                return nil</span>
        }
}

// IterateCallback is called when we iterate the database on each decoded object
type IterateCallback func([]byte, []byte, DiskKey, int64, error)

// IterateDatabase will call f() on every item inside the database after extracting it into
// the datum/tsid pair
func (dc *DiskCache) IterateDatabase(f IterateCallback) error <span class="cov8" title="1">{
        return dc.db.View(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                bucket := tx.Bucket(dc.tsidBucket)
                if bucket == nil </span><span class="cov8" title="1">{
                        return errBucketDoesNotExist
                }</span>
                <span class="cov8" title="1">return bucket.ForEach(bucketIteration(dc.byteEncoder, f))</span>
        })
}

func bucketIteration(byteEncoder binary.ByteOrder, f IterateCallback) func(k, v []byte) error <span class="cov8" title="1">{
        inverseMap := make(map[int64]struct{})

        return func(k, v []byte) error </span><span class="cov8" title="1">{
                var diskKey DiskKey
                var err error
                var tsid int64
                defer func() </span><span class="cov8" title="1">{
                        f(k, v, diskKey, tsid, err)
                }</span>()
                <span class="cov8" title="1">err = diskKey.DecodeOld(k)
                if err != nil </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">if len(v) != 8 </span><span class="cov8" title="1">{
                        err = errInvalidKeyLength
                        return nil
                }</span>
                <span class="cov8" title="1">tsid = int64(byteEncoder.Uint64(v))
                if tsid &lt;= 0 </span><span class="cov8" title="1">{
                        err = errInvalidTsid
                        return nil
                }</span>

                <span class="cov8" title="1">_, existing := inverseMap[tsid]
                if existing </span><span class="cov8" title="1">{
                        err = errSameTsidTwice
                        return nil
                }</span>
                <span class="cov8" title="1">inverseMap[tsid] = struct{}{}
                return nil</span>
        }
}

// Close the disk cache, making the db unable to process more requests.
func (dc *DiskCache) Close() error <span class="cov8" title="1">{
        close(dc.diskStatLoop)
        close(dc.rotationLoop)
        return dc.db.Close()
}</span>

var errBucketDoesNotExist = errors.New("bucket does not exist")
var errBadBufferLength = errors.New("buffer length incorrect")

func (dc *DiskCache) readItems(_ *bytes.Buffer, items []Encodeable) ([]int64, error) <span class="cov8" title="1">{
        ret := make([]int64, len(items))
        readBytes := make([][]byte, len(items))
        for i, item := range items </span><span class="cov8" title="1">{
                var buf2 bytes.Buffer
                if err := item.EncodeCycle(&amp;buf2); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">readBytes[i] = buf2.Bytes()</span>
        }
        <span class="cov8" title="1">cycleKeys, err := dc.cycleDB.Read(readBytes)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for i, cycleKey := range cycleKeys </span><span class="cov8" title="1">{
                if cycleKey != nil </span><span class="cov8" title="1">{
                        if len(cycleKey) != 8 </span><span class="cov8" title="1">{
                                return nil, errBadBufferLength
                        }</span>
                        <span class="cov8" title="1">ret[i] = int64(dc.byteEncoder.Uint64(cycleKey))</span>
                }
        }
        <span class="cov8" title="1">return ret, nil</span>
}

func countNonZeroValues(val []int64) (int, int) <span class="cov8" title="1">{
        hits := 0
        misses := 0
        for _, v := range val </span><span class="cov8" title="1">{
                if v == 0 </span><span class="cov8" title="1">{
                        misses++
                }</span><span class="cov8" title="1"> else {
                        hits++
                }</span>
        }
        <span class="cov8" title="1">return hits, misses</span>
}

// Tsid will fetch the TSID for a datum from the disk.  Will return zero if the TSID is not in the
// database.  It uses buf for memory scratch during the operation.
func (dc *DiskCache) Tsid(buf *bytes.Buffer, items []Encodeable) ([]int64, error) <span class="cov8" title="1">{
        ret, err := dc.readItems(buf, items)
        if err != nil </span><span class="cov8" title="1">{
                return ret, err
        }</span>
        <span class="cov8" title="1">hits, misses := countNonZeroValues(ret)
        atomic.AddInt64(&amp;dc.stats.newDBReadHits, int64(hits))
        atomic.AddInt64(&amp;dc.stats.newDBReadMisses, int64(misses))
        if misses == 0 || !dc.useOldDB.Get() </span><span class="cov8" title="1">{
                return ret, nil
        }</span>

        <span class="cov8" title="1">foundInOldDB := make(map[Encodeable]int64, misses)

        err = dc.db.View(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                bucket := tx.Bucket(dc.tsidBucket)
                if bucket == nil </span><span class="cov8" title="1">{
                        return errBucketDoesNotExist
                }</span>
                <span class="cov8" title="1">cur := bucket.Cursor()
                for i := range items </span><span class="cov8" title="1">{
                        if ret[i] != 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">buf.Reset()
                        if err := items[i].EncodeOld(buf); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">k, res := cur.Seek(buf.Bytes())
                        if !bytes.Equal(buf.Bytes(), k) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if len(res) != 8 </span><span class="cov8" title="1">{
                                return errBadBufferLength
                        }</span>
                        <span class="cov8" title="1">ret[i] = int64(dc.byteEncoder.Uint64(res))
                        foundInOldDB[items[i]] = ret[i]</span>
                }
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">dc.copyBack(foundInOldDB)
        return ret, err</span>
}

func (dc *DiskCache) copyBack(foundInOldDB map[Encodeable]int64) <span class="cov8" title="1">{
        if len(foundInOldDB) &gt; 0 </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;dc.stats.newDBRecopy, int64(len(foundInOldDB)))
                // Rewrite those back to the database
                writes, err := dc.encodeBytesForCycleDB(foundInOldDB)
                if err != nil </span><span class="cov8" title="1">{
                        log.WithField("err", err).Warn("Error encoding bytes back to DB")
                        atomic.AddInt64(&amp;dc.stats.copyBackFailures, 1)
                        return
                }</span>
                <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.TODO(), time.Second)
                // Note: Must cancel the context when done so we don't leak timer objects
                defer cancel()
                dc.cycleDB.AsyncWrite(ctx, writes)
                return</span>
        }
}

// BackupHandler is a HTTP handler that writes to w the contents of the database.
func (dc *DiskCache) BackupHandler(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        err := dc.db.View(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "application/octet-stream")
                w.Header().Set("Content-Disposition", `attachment; filename="tsidcache.bolt"`)
                w.Header().Set("Content-Length", strconv.Itoa(int(tx.Size())))
                if validAtTimestamp, err := dc.ValidAtTimestamp(); err == nil </span><span class="cov8" title="1">{
                        w.Header().Set("Last-Modified", validAtTimestamp.UTC().Format(http.TimeFormat))
                }</span>
                <span class="cov8" title="1">if strings.ToUpper(req.Method) == "HEAD" </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">return tx.Copy(w)</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
        }</span>
}

// ExploreHandle is a HTTP handler that writes to HTTP the contents of the database.
func (dc *DiskCache) ExploreHandle() http.Handler <span class="cov8" title="1">{
        return boltd.NewHandler(dc.db)
}</span>

// Stats are internal tracking information about the disk cache
type Stats struct {
        BucketStats bolt.BucketStats
        DbStats     bolt.Stats
        FileSize    int64
}

// Stats returns internal tracking information about the disk cache, or an error if it cannot
// read disk data
func (dc *DiskCache) Stats() (Stats, error) <span class="cov8" title="1">{
        var stats Stats

        stats.DbStats = dc.db.Stats()
        err := dc.db.View(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                bucket := tx.Bucket(dc.tsidBucket)
                if bucket == nil </span><span class="cov8" title="1">{
                        return errBucketDoesNotExist
                }</span>
                <span class="cov8" title="1">stats.FileSize = tx.Size()
                stats.BucketStats = bucket.Stats()
                return nil</span>
        })
        <span class="cov8" title="1">return stats, err</span>
}

func (dc *DiskCache) encodeTsid(tsid int64) []byte <span class="cov8" title="1">{
        var key [8]byte
        dc.byteEncoder.PutUint64(key[:], uint64(tsid))
        return key[:]
}</span>

func (dc *DiskCache) encodeBytesForCycleDB(res map[Encodeable]int64) ([]boltcycle.KvPair, error) <span class="cov8" title="1">{
        writes := make([]boltcycle.KvPair, 0, len(res))
        for e, tsid := range res </span><span class="cov8" title="1">{
                var buf2 bytes.Buffer
                if err := e.EncodeCycle(&amp;buf2); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">val := dc.encodeTsid(tsid)
                writes = append(writes, boltcycle.KvPair{
                        Key:   buf2.Bytes(),
                        Value: val,
                })</span>
        }
        <span class="cov8" title="1">return writes, nil</span>
}

func (dc *DiskCache) writeInCycleDB(_ *bytes.Buffer, res map[Encodeable]int64) error <span class="cov8" title="1">{
        writes, err := dc.encodeBytesForCycleDB(res)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return dc.cycleDB.Write(writes)</span>
}

// WriteResult will write a result of a thrift request to the on disk cache.
func (dc *DiskCache) WriteResult(buf *bytes.Buffer, res map[Encodeable]int64) error <span class="cov8" title="1">{
        // TODO: Add flag for which part to enable
        err := dc.writeInCycleDB(buf, res)
        if !dc.useOldDB.Get() </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return firstNonNil(err, dc.db.Update(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                bucket := tx.Bucket(dc.tsidBucket)
                if bucket == nil </span><span class="cov8" title="1">{
                        return errBucketDoesNotExist
                }</span>
                <span class="cov8" title="1">for dk, tsid := range res </span><span class="cov8" title="1">{
                        // Note: It calls cloneValues() on the value, but not on the key so I cannot reuse the key
                        buf.Reset()
                        if err := dk.EncodeOld(buf); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">key := dc.encodeTsid(tsid)
                        if err := bucket.Put(buf.Bytes(), key); err != nil </span><span class="cov8" title="1">{
                                log.WithField("res", res).WithField("key", buf.String()).Warn("Unable to write result to db")
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }))
}

// RemoveResult removes each encodable object from the on disk cache.  Does nothing for Encodables
// that don't exist
func (dc *DiskCache) RemoveResult(buf *bytes.Buffer, res []Encodeable) error <span class="cov8" title="1">{
        tmpBufs := make([]bytes.Buffer, len(res))
        tmpBytes := make([][]byte, len(res))
        for i, e := range res </span><span class="cov8" title="1">{
                e.EncodeCycle(&amp;tmpBufs[i])
                tmpBytes[i] = tmpBufs[i].Bytes()
        }</span>
        <span class="cov8" title="1">_, err := dc.cycleDB.Delete(tmpBytes)
        if !dc.useOldDB.Get() </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return firstNonNil(err, dc.db.Update(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                bucket := tx.Bucket(dc.tsidBucket)
                if bucket == nil </span><span class="cov8" title="1">{
                        return errBucketDoesNotExist
                }</span>
                <span class="cov8" title="1">for _, dk := range res </span><span class="cov8" title="1">{
                        // Note: It calls cloneValues() on the value, but not on the key so I cannot reuse the key
                        buf.Reset()
                        if err := dk.EncodeOld(buf); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := bucket.Delete(buf.Bytes()); err != nil </span><span class="cov8" title="1">{
                                log.WithField("res", res).WithField("key", buf.String()).Warn("Unable to delete result from db")
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }))
}

func firstNonNil(errs ...error) error <span class="cov8" title="1">{
        for _, err := range errs </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
