
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/signalfx/golib/ketama/ketama.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package ketama

// Package ketama implements consistent hashing compatible with Algorithm::ConsistentHash::Ketama
// This is a fork of https://github.com/dgryski/go-ketama/blob/master/ketama.go written in a
// more extendable way

/*
This implementation draws from the Daisuke Maki's Perl module, which itself is
based on the original libketama code.  That code was licensed under the GPLv2,
and thus so is this.
The major API change from libketama is that Algorithm::ConsistentHash::Ketama allows hashing
arbitrary strings, instead of just memcached server IP addresses.
*/
import (
        "crypto/md5"
        "encoding/binary"
        "fmt"
        "sort"
)

// Bucket is a source we hash into.  The Label() is used as the hash key and Weight represents
// how much we weight this bucket against others
type Bucket interface {
        Label() string
        Weight() uint32
}

type continuumPoint struct {
        bucket Bucket
        point  uint32
}

// Continuum stores the ketama hashring and allows users to hash bytes into the ring
type Continuum struct {
        ring    points
        buckets []Bucket
}

type points []continuumPoint

func (c points) Less(i, j int) bool <span class="cov8" title="1">{ return c[i].point &lt; c[j].point }</span>
func (c points) Len() int           <span class="cov8" title="1">{ return len(c) }</span>
func (c points) Swap(i, j int)      <span class="cov8" title="1">{ c[i], c[j] = c[j], c[i] }</span>

// New creates a new Continuum that uses the passed Buckets as parts of the ring
func New(buckets []Bucket) *Continuum <span class="cov8" title="1">{
        var ret Continuum
        ret.Reset(buckets)
        return &amp;ret
}</span>

// Buckets returns the buckets last set in the continuum
func (c *Continuum) Buckets() []Bucket <span class="cov8" title="1">{
        return c.buckets
}</span>

// Reset the Continuum to use the given buckets in the hashring
func (c *Continuum) Reset(buckets []Bucket) <span class="cov8" title="1">{
        numbuckets := len(buckets)

        ring := make(points, 0, numbuckets*160)

        if numbuckets == 0 </span><span class="cov8" title="1">{
                c.ring = ring
                return
        }</span>

        <span class="cov8" title="1">totalweight := uint32(0)
        for _, b := range buckets </span><span class="cov8" title="1">{
                totalweight += b.Weight()
        }</span>

        <span class="cov8" title="1">for i, b := range buckets </span><span class="cov8" title="1">{
                pct := float32(b.Weight()) / float32(totalweight)

                // this is the equivalent of C's promotion rules, but in Go, to maintain exact compatibility with the C library
                limit := int(float32(float64(pct) * 40.0 * float64(numbuckets)))

                for k := 0; k &lt; limit; k++ </span><span class="cov8" title="1">{
                        /* 40 hashes, 4 numbers per hash = 160 points per bucket */
                        ss := fmt.Sprintf("%s-%d", b.Label(), k)
                        digest := md5.Sum([]byte(ss))

                        for h := 0; h &lt; 4; h++ </span><span class="cov8" title="1">{
                                point := continuumPoint{
                                        point:  binary.LittleEndian.Uint32(digest[h*4:]),
                                        bucket: buckets[i],
                                }
                                ring = append(ring, point)
                        }</span>
                }
        }

        <span class="cov8" title="1">sort.Sort(ring)

        c.ring = ring
        c.buckets = buckets</span>
}

// Hash an array of bytes into a location in the ring
func (c *Continuum) Hash(thing []byte) Bucket <span class="cov8" title="1">{
        hash := md5.Sum(thing)

        h := binary.LittleEndian.Uint32(hash[0:4])
        return c.Bucket(h)
}</span>

// Bucket returns the bucket at or after a location in the ring
func (c *Continuum) Bucket(ringLocation uint32) Bucket <span class="cov8" title="1">{
        if c == nil || len(c.ring) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">i := uint(sort.Search(len(c.ring), func(i int) bool </span><span class="cov8" title="1">{ return c.ring[i].point &gt;= ringLocation }</span>))
        <span class="cov8" title="1">if i &gt;= uint(len(c.ring)) </span><span class="cov8" title="1">{
                i = 0
        }</span>

        <span class="cov8" title="1">return c.ring[i].bucket</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
