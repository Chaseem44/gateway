
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/signalfx/golib/maestro/load.go (100.0%)</option>
				
				<option value="file1">github.com/signalfx/golib/maestro/maestro.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package maestro

import (
        "encoding/json"
        "fmt"

        "github.com/signalfx/golib/safeexec"
)

// Ships are the location of an instance
type Ships struct {
        IP string
}

// Port is the port a service is running in.  Can sometimes be port ranges...
type Port interface{}

// EnvVal is the value in the instance's shell env
type EnvVal interface{}

// Instance running code
type Instance struct {
        Ports map[string]Port
        Ship  string
}

// Service running in maestro
type Service struct {
        Instances map[string]Instance
        Env       map[string]EnvVal
}

// A Config is our maestro config
type Config struct {
        Name     string
        Ships    map[string]Ships
        Services map[string]Service
}

// ShipsForService is a helper that gets the connections for a service inside a config
func (c *Config) ShipsForService(name string) []string <span class="cov8" title="1">{
        zkInstances := c.Services[name].Instances
        inst := make([]string, 0, len(zkInstances))
        for _, i := range zkInstances </span><span class="cov8" title="1">{
                zkShip := c.Ships[i.Ship]
                c := fmt.Sprintf("%s:%d", zkShip.IP, int64(i.Ports["client"].(float64)))
                inst = append(inst, c)
        }</span>
        <span class="cov8" title="1">return inst</span>
}

// ArbitraryInstance returns a (possibly random) instance in a map, or panics if the map is empty
func ArbitraryInstance(m map[string]Instance) Instance <span class="cov8" title="1">{
        for _, v := range m </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov8" title="1">panic("I panic if the map is empty")</span>
}

// Loader can load a maestro config execing out to the python module and returning its json
// object.
type Loader struct {
        ExecFunc       func(name string, stdin string, args ...string) (string, string, error)
        PythonLocation string
}

// LoadError is returned when Load() fails, including extra information about the python error.
type LoadError struct {
        error
        stdout string
        stderr string
}

func (l *LoadError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s %s %s", l.error, l.stdout, l.stderr)
}</span>

// Load a maestro config, shelling out to python
func (l *Loader) Load(filename string) (*Config, error) <span class="cov8" title="1">{
        f := l.ExecFunc
        if f == nil </span><span class="cov8" title="1">{
                f = safeexec.Execute
        }</span>
        <span class="cov8" title="1">pythonLocation := l.PythonLocation
        if pythonLocation == "" </span><span class="cov8" title="1">{
                pythonLocation = "python"
        }</span>
        <span class="cov8" title="1">stdout, stderr, err := f(pythonLocation, filename, "-c", "import maestro.__main__ as maestro, sys, json;print json.dumps(maestro.load_config_from_file(sys.stdin.readline().strip()))")
        if err != nil </span><span class="cov8" title="1">{
                return nil, &amp;LoadError{error: err, stdout: stdout, stderr: stderr}
        }</span>
        <span class="cov8" title="1">var conf Config

        if err = json.Unmarshal([]byte(stdout), &amp;conf); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;conf, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package maestro

import (
        "errors"
        "fmt"
        "regexp"
        "strconv"
        "strings"
)

// Maestro is the golang client for https://github.com/signalfuse/maestro-ng
type Maestro struct {
        // Stub for os.Getenv
        osGetenv func(string) string
}

// New creates a new maestro client, using the given function to get env variables.  You usually
// want to call New(os.Getenv)
func New(osGetenv func(string) string) *Maestro <span class="cov8" title="1">{
        return &amp;Maestro{
                osGetenv: osGetenv,
        }
}</span>

// GetEnvironmentName returns the name of the environment the container calling this in a part of
func (m *Maestro) GetEnvironmentName() string <span class="cov8" title="1">{
        val := m.osGetenv("MAESTRO_ENVIRONMENT_NAME")
        if val == "" </span><span class="cov8" title="1">{
                return "local"
        }</span>
        <span class="cov8" title="1">return val</span>
}

// ErrContainerHostAddrNotDefined is returned when GetContainerHostAddress is not defined
var ErrContainerHostAddrNotDefined = errors.New("container host address was not defined")

// GetContainerHostAddress returns the publicly-addressable IP address of the host of the container
func (m *Maestro) GetContainerHostAddress() (string, error) <span class="cov8" title="1">{
        address := m.osGetenv("CONTAINER_HOST_ADDRESS")
        if address == "" </span><span class="cov8" title="1">{
                return "", ErrContainerHostAddrNotDefined
        }</span>
        <span class="cov8" title="1">return address, nil</span>
}

// ErrNoServiceName is returned when GetServiceName is not defined
var ErrNoServiceName = errors.New("service name was not defined")

// GetServiceName returns the service name of the container calling it
func (m *Maestro) GetServiceName() (string, error) <span class="cov8" title="1">{
        address := m.osGetenv("SERVICE_NAME")
        if address == "" </span><span class="cov8" title="1">{
                return "", ErrNoServiceName
        }</span>
        <span class="cov8" title="1">return address, nil</span>
}

// ErrNoContainerName is returned when GetContainerName is not defined
var ErrNoContainerName = errors.New("container name was not defined")

// GetContainerName returns the name of the container calling it
func (m *Maestro) GetContainerName() (string, error) <span class="cov8" title="1">{
        address := m.osGetenv("CONTAINER_NAME")
        if address == "" </span><span class="cov8" title="1">{
                return "", ErrNoContainerName
        }</span>
        <span class="cov8" title="1">return address, nil</span>
}

// ErrPortNotDefined is returned when the port cannot be found
var ErrPortNotDefined = errors.New("port env not defined")

// GetSpecificExposedPort returns the exposed (internal) port number of a specific port of a
// specific container from a given service.
func (m *Maestro) GetSpecificExposedPort(service string, container string, port string) (uint16, error) <span class="cov8" title="1">{
        return m.getPortHelper(service, container, port, "INTERNAL_PORT")
}</span>

// ErrNoSpecificHostDefined is returned when GetSpecificHost cannot find the host in the container
var ErrNoSpecificHostDefined = errors.New("no host defined for container of service")

// GetSpecificHost returns the hostname/address of a specific container/instance of the given service
func (m *Maestro) GetSpecificHost(service string, container string) (string, error) <span class="cov8" title="1">{
        envKey := fmt.Sprintf("%s_%s_HOST", m.toEnvVarName(service), m.toEnvVarName(container))
        envVal := m.osGetenv(envKey)
        if envVal == "" </span><span class="cov8" title="1">{
                return "", ErrNoSpecificHostDefined
        }</span>
        <span class="cov8" title="1">return envVal, nil</span>
}

// GetPort returns the exposed (internal) port number for the given port
func (m *Maestro) GetPort(name string) (uint16, error) <span class="cov8" title="1">{
        sname, err := m.GetServiceName()
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">cname, err := m.GetContainerName()
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return m.GetSpecificExposedPort(sname, cname, name)</span>
}

// GetSpecificPort returns the external port number of a specific port of a specific
// container from a given service
func (m *Maestro) GetSpecificPort(service string, container string, port string) (uint16, error) <span class="cov8" title="1">{
        return m.getPortHelper(service, container, port, "PORT")
}</span>

func (m *Maestro) getPortHelper(service string, container string, port string, key string) (uint16, error) <span class="cov8" title="1">{
        envKey := fmt.Sprintf("%s_%s_%s_%s", m.toEnvVarName(service), m.toEnvVarName(container), m.toEnvVarName(port), key)
        envVal := m.osGetenv(strings.ToUpper(envKey))
        if envVal == "" </span><span class="cov8" title="1">{
                return 0, ErrPortNotDefined
        }</span>
        <span class="cov8" title="1">portInt, err := strconv.ParseUint(envVal, 10, 16)
        return uint16(portInt), err</span>
}

// GetNodeList builds a list of nodes for the given service from the environment,
// eventually adding the ports from the list of port names. The resulting
// entries will be of the form 'host[:port1[:port2]]' and sorted by container name.
func (m *Maestro) GetNodeList(service string, ports []string) []string <span class="cov8" title="1">{
        nodes := []string{}
        for _, container := range m.getServiceInstanceNames(service) </span><span class="cov8" title="1">{
                node, err := m.GetSpecificHost(service, container)
                if err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">for _, port := range ports </span><span class="cov8" title="1">{
                        p, err := m.GetSpecificPort(service, container, port)
                        if err != nil </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">node = fmt.Sprintf("%s:%d", node, p)</span>
                }
                <span class="cov8" title="1">nodes = append(nodes, node)</span>
        }
        <span class="cov8" title="1">return nodes</span>
}

func (m *Maestro) toEnvVarName(name string) string <span class="cov8" title="1">{
        return strings.ToUpper(string(regexp.MustCompile(`[^\w]`).ReplaceAll([]byte(name), []byte("_"))))
}</span>

func (m *Maestro) getServiceInstanceNames(service string) []string <span class="cov8" title="1">{
        key := fmt.Sprintf("%s_INSTANCES", m.toEnvVarName(service))
        val := m.osGetenv(key)
        if val == "" </span><span class="cov8" title="1">{
                return []string{}
        }</span>
        <span class="cov8" title="1">return strings.Split(val, ",")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
