
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/signalfx/golib/zkplus/zktest/zktest.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package zktest

import (
        "strings"
        "time"

        "errors"

        "sync"

        "github.com/Sirupsen/logrus"
        "github.com/samuel/go-zookeeper/zk"
)

type event struct {
        path  string
        event zk.Event
}

// ErrDeleteOnRoot is returned when EnsureDelete is called with a root path
var ErrDeleteOnRoot = errors.New("cannot delete on root path")

// ErrDeleteFailed is retured when EnsureDelete() is unable to ensure the delete
var ErrDeleteFailed = errors.New("delete eventually failed")

// EnsureDelete will ensure that path is deleted from zk, trying up to three times before eventually
// failing with an error
func EnsureDelete(z ZkConnSupported, path string) error <span class="cov8" title="1">{
        if path == "/" </span><span class="cov8" title="1">{
                return ErrDeleteOnRoot
        }</span>
        <span class="cov8" title="1">c, _, err := z.Children(path)
        if err == nil </span><span class="cov8" title="1">{
                wg := sync.WaitGroup{}
                var err error
                for _, chil := range c </span><span class="cov8" title="1">{
                        wg.Add(1)
                        go func(chil string) </span><span class="cov8" title="1">{
                                defer wg.Done()
                                err = EnsureDelete(z, path+"/"+chil)
                                if err != nil </span><span class="cov8" title="1">{
                                        return
                                }</span>
                        }(chil)
                }
                <span class="cov8" title="1">wg.Wait()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">for i := 0; i &lt; 3; i++ </span><span class="cov8" title="1">{
                err = z.Delete(path, -1)
                if err == nil || err == zk.ErrNoNode </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return ErrDeleteFailed</span>
}

// MemoryZkServer can be used in the place of a zk.Conn() to unit test zk connections
type MemoryZkServer struct {
        root       *zkNode
        rootLock   sync.Mutex
        GlobalChan chan zk.Event

        events chan event

        forcedErrorCheck ErrorCheckFunction
        errCheckMutex    sync.Mutex

        childrenConnectionsLock sync.Mutex
        childrenConnections     map[*ZkConn]struct{}
        ChanTimeout             time.Duration
}

// ZkConn is the connection type returned from a MemoryZkConn that simulates a zk connection
type ZkConn struct {
        connectedTo   *MemoryZkServer
        events        chan zk.Event
        pathWatch     map[string]chan zk.Event
        pathWatchLock sync.Mutex

        chanTimeout    time.Duration
        methodCallLock sync.Mutex

        forcedErrorCheck ErrorCheckFunction
        errCheckMutex    sync.Mutex
}

// Pretty returns a pretty print of the zk structure
func (z *MemoryZkServer) Pretty() string <span class="cov8" title="1">{
        return z.root.pretty(0)
}</span>

// ErrorCheckFunction is a way to simulate zk errors for a call name
type ErrorCheckFunction func(methodName string) error

// ForcedErrorCheck sets the function used to simulate errors
func (z *MemoryZkServer) ForcedErrorCheck(f ErrorCheckFunction) <span class="cov8" title="1">{
        z.errCheckMutex.Lock()
        defer z.errCheckMutex.Unlock()
        z.forcedErrorCheck = f
}</span>

func (z *MemoryZkServer) check(s string) error <span class="cov8" title="1">{
        z.errCheckMutex.Lock()
        defer z.errCheckMutex.Unlock()
        if z.forcedErrorCheck == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return z.forcedErrorCheck(s)</span>
}

// ForcedErrorCheck sets the function used to simulate errors
func (z *ZkConn) ForcedErrorCheck(f ErrorCheckFunction) <span class="cov8" title="1">{
        z.errCheckMutex.Lock()
        defer z.errCheckMutex.Unlock()
        z.forcedErrorCheck = f
}</span>

func (z *ZkConn) check(s string) error <span class="cov8" title="1">{
        z.errCheckMutex.Lock()
        defer z.errCheckMutex.Unlock()
        if z.forcedErrorCheck == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return z.forcedErrorCheck(s)</span>
}

func (z *zkNode) pretty(tabsize int) string <span class="cov8" title="1">{
        t := strings.Repeat("\t", tabsize)
        s := []string{(t + z.name + "-&gt;" + string(z.data))}
        for _, c := range z.children </span><span class="cov8" title="1">{
                s = append(s, c.pretty(tabsize+1))
        }</span>
        <span class="cov8" title="1">return strings.Join(s, "\n")</span>
}

type zkNode struct {
        data     []byte
        children map[string]*zkNode
        name     string
        parent   *zkNode
        stat     *zk.Stat
}

// New returns a new testing zk connection
func New() *MemoryZkServer <span class="cov8" title="1">{
        GlobalChan := make(chan zk.Event, 5)
        z := &amp;MemoryZkServer{
                root: &amp;zkNode{
                        data:     []byte(""),
                        children: make(map[string]*zkNode),
                        name:     "",
                        parent:   nil,
                        stat:     &amp;zk.Stat{},
                },
                GlobalChan:          GlobalChan,
                events:              make(chan event),
                childrenConnections: make(map[*ZkConn]struct{}),
                ChanTimeout:         time.Second,
        }
        return z
}</span>

// Conn satisfies the ZkConnector interface for zkplus so we can easily pass the memory zk server
// into a builder
func (z *MemoryZkServer) Conn() (ZkConnSupported, &lt;-chan zk.Event, error) <span class="cov8" title="1">{
        return z.Connect()
}</span>

// Connect to this server
func (z *MemoryZkServer) Connect() (*ZkConn, &lt;-chan zk.Event, error) <span class="cov8" title="1">{
        r := &amp;ZkConn{
                connectedTo: z,
                events:      make(chan zk.Event, 1000),
                pathWatch:   make(map[string]chan zk.Event),
                chanTimeout: z.ChanTimeout,
        }
        z.childrenConnectionsLock.Lock()
        defer z.childrenConnectionsLock.Unlock()
        z.childrenConnections[r] = struct{}{}
        r.events &lt;- zk.Event{
                Type:   zk.EventSession,
                State:  zk.StateConnecting,
                Server: "localhost",
        }
        r.events &lt;- zk.Event{
                Type:   zk.EventSession,
                State:  zk.StateHasSession,
                Server: "localhost",
        }
        return r, r.events, nil
}</span>

func (z *MemoryZkServer) addEvent(e zk.Event) <span class="cov8" title="1">{
        z.childrenConnectionsLock.Lock()
        defer z.childrenConnectionsLock.Unlock()
        for conn := range z.childrenConnections </span><span class="cov8" title="1">{
                conn.offerEvent(e)
        }</span>
}

func (z *MemoryZkServer) removeConnection(c *ZkConn) <span class="cov8" title="1">{
        z.childrenConnectionsLock.Lock()
        defer z.childrenConnectionsLock.Unlock()
        delete(z.childrenConnections, c)
}</span>

func (z *ZkConn) offerEvent(e zk.Event) <span class="cov8" title="1">{
        z.pathWatchLock.Lock()
        defer z.pathWatchLock.Unlock()
        if z.pathWatch == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">w, exists := z.pathWatch[e.Path]
        logrus.WithField("e", e).WithField("exists", exists).Info("Event on path")
        if exists </span><span class="cov8" title="1">{
                logrus.WithField("e", e).WithField("exists", exists).Info("Firing event!")
                delete(z.pathWatch, e.Path)
                go func() </span><span class="cov8" title="1">{
                        select </span>{
                        <span class="cov8" title="1">case w &lt;- e:
                                logrus.WithField("e", e).WithField("exists", exists).Info("event sent!")</span>
                        <span class="cov0" title="0">case &lt;-time.After(z.chanTimeout):</span>
                        }
                        <span class="cov8" title="1">close(w)</span>
                }()

                <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                        select </span>{
                        <span class="cov8" title="1">case z.events &lt;- e:
                                logrus.WithField("e", e).WithField("exists", exists).Info("event sent!")</span>
                        <span class="cov0" title="0">case &lt;-time.After(z.chanTimeout):</span>
                        }
                }()
        }
}

func (z *zkNode) path() string <span class="cov8" title="1">{
        if z.parent == nil </span><span class="cov8" title="1">{
                return z.name
        }</span>
        <span class="cov8" title="1">return z.parent.path() + "/" + z.name</span>
}

func (z *MemoryZkServer) node(path string) (*zkNode, *zkNode) <span class="cov8" title="1">{
        parts := strings.Split(path, "/")
        parent := (*zkNode)(nil)
        at := z.root
        for _, part := range parts </span><span class="cov8" title="1">{
                if part == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if at == nil </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">nextDir := at.children[part]
                parent = at
                at = nextDir</span>
        }
        <span class="cov8" title="1">return at, parent</span>
}

// ZkConnSupported is the interface of zk.Conn we currently support
type ZkConnSupported interface {
        // Exists returns true if the path exists
        Exists(path string) (bool, *zk.Stat, error)
        ExistsW(path string) (bool, *zk.Stat, &lt;-chan zk.Event, error)
        Get(path string) ([]byte, *zk.Stat, error)
        GetW(path string) ([]byte, *zk.Stat, &lt;-chan zk.Event, error)
        Children(path string) ([]string, *zk.Stat, error)
        ChildrenW(path string) ([]string, *zk.Stat, &lt;-chan zk.Event, error)
        Delete(path string, version int32) error
        Create(path string, data []byte, flags int32, acl []zk.ACL) (string, error)
        Set(path string, data []byte, version int32) (*zk.Stat, error)
        Close()
}

var _ ZkConnSupported = &amp;zk.Conn{}
var _ ZkConnSupported = &amp;ZkConn{}

// Close sends disconnected to all waiting events and deregisteres this
// conn with the parent server
func (z *ZkConn) Close() <span class="cov8" title="1">{
        z.pathWatchLock.Lock()
        var wg sync.WaitGroup
        for _, e := range z.pathWatch </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(e chan zk.Event) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        select </span>{
                        <span class="cov8" title="1">case e &lt;- zk.Event{
                                State: zk.StateDisconnected,
                        }:</span>
                        <span class="cov8" title="1">case &lt;-time.After(z.chanTimeout):</span>
                        }
                }(e)
        }
        <span class="cov8" title="1">wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                select </span>{
                <span class="cov8" title="1">case z.events &lt;- zk.Event{
                        State: zk.StateDisconnected,
                }:</span>
                <span class="cov0" title="0">case &lt;-time.After(z.chanTimeout):</span>
                }
        }()
        <span class="cov8" title="1">z.pathWatch = nil
        z.pathWatchLock.Unlock()
        wg.Wait()
        z.connectedTo.removeConnection(z)</span>
}

func (z *MemoryZkServer) exists(path string) (bool, *zk.Stat, error) <span class="cov8" title="1">{
        path = fixPath(path)
        z.rootLock.Lock()
        defer z.rootLock.Unlock()
        if err := z.check("exists"); err != nil </span><span class="cov8" title="1">{
                return false, nil, err
        }</span>
        <span class="cov8" title="1">at, _ := z.node(path)
        if at == nil </span><span class="cov8" title="1">{
                return false, nil, nil
        }</span>
        <span class="cov8" title="1">return true, at.stat, nil</span>
}

// Exists returns true if the path exists
func (z *ZkConn) Exists(path string) (bool, *zk.Stat, error) <span class="cov8" title="1">{
        z.methodCallLock.Lock()
        defer z.methodCallLock.Unlock()
        if err := z.check("exists"); err != nil </span><span class="cov8" title="1">{
                return false, nil, err
        }</span>
        <span class="cov8" title="1">return z.connectedTo.exists(path)</span>
}

func fixPath(path string) string <span class="cov8" title="1">{
        if len(path) &gt; 0 &amp;&amp; path[0] != '/' </span><span class="cov8" title="1">{
                return "/" + path
        }</span>
        <span class="cov8" title="1">return path</span>
}

// ExistsW is like Exists but also sets a watch.
func (z *ZkConn) ExistsW(path string) (bool, *zk.Stat, &lt;-chan zk.Event, error) <span class="cov8" title="1">{
        z.methodCallLock.Lock()
        defer z.methodCallLock.Unlock()
        if err := z.check("exists"); err != nil </span><span class="cov8" title="1">{
                return false, nil, nil, err
        }</span>
        <span class="cov8" title="1">e, s, err := z.connectedTo.exists(path)
        return e, s, z.patchWatch(path), err</span>
}

func (z *MemoryZkServer) get(path string) ([]byte, *zk.Stat, error) <span class="cov8" title="1">{
        z.rootLock.Lock()
        defer z.rootLock.Unlock()
        if err := z.check("get"); err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">at, _ := z.node(path)
        if at == nil </span><span class="cov8" title="1">{
                return nil, nil, zk.ErrNoNode
        }</span>
        <span class="cov8" title="1">return at.data, at.stat, nil</span>
}

// Get the bytes of a zk path
func (z *ZkConn) Get(path string) ([]byte, *zk.Stat, error) <span class="cov8" title="1">{
        if err := z.check("get"); err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">return z.connectedTo.get(path)</span>
}

// GetW is like Get, but also sets a watch
func (z *ZkConn) GetW(path string) ([]byte, *zk.Stat, &lt;-chan zk.Event, error) <span class="cov8" title="1">{
        z.methodCallLock.Lock()
        defer z.methodCallLock.Unlock()
        if err := z.check("getw"); err != nil </span><span class="cov8" title="1">{
                return nil, nil, nil, err
        }</span>
        <span class="cov8" title="1">e, s, err := z.Get(path)
        if err != nil </span><span class="cov8" title="1">{
                return e, s, nil, err
        }</span>
        <span class="cov8" title="1">return e, s, z.patchWatch(path), err</span>
}

func (z *ZkConn) patchWatch(path string) chan zk.Event <span class="cov8" title="1">{
        path = fixPath(path)
        logrus.WithField("path", path).Info("Should I set a path watch?")
        z.pathWatchLock.Lock()
        defer z.pathWatchLock.Unlock()
        if z.pathWatch == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">ch, exists := z.pathWatch[path]
        if !exists </span><span class="cov8" title="1">{
                logrus.WithField("path", path).Info("Setting patch watch")
                ch = make(chan zk.Event)
                z.pathWatch[path] = ch
        }</span>
        <span class="cov8" title="1">return ch</span>
}

func (z *MemoryZkServer) children(path string) ([]string, *zk.Stat, error) <span class="cov8" title="1">{
        if err := z.check("children"); err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">z.rootLock.Lock()
        defer z.rootLock.Unlock()
        at, _ := z.node(path)
        if at == nil </span><span class="cov8" title="1">{
                return nil, nil, zk.ErrNoNode
        }</span>

        <span class="cov8" title="1">childrenNames := []string{}
        for k := range at.children </span><span class="cov8" title="1">{
                childrenNames = append(childrenNames, k)
        }</span>
        <span class="cov8" title="1">return childrenNames, at.stat, nil</span>
}

// Children gets children of a path
func (z *ZkConn) Children(path string) ([]string, *zk.Stat, error) <span class="cov8" title="1">{
        if err := z.check("children"); err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">return z.connectedTo.children(path)</span>
}

// ChildrenW is like children but also sets a watch
func (z *ZkConn) ChildrenW(path string) ([]string, *zk.Stat, &lt;-chan zk.Event, error) <span class="cov8" title="1">{
        z.methodCallLock.Lock()
        defer z.methodCallLock.Unlock()
        if err := z.check("childrenw"); err != nil </span><span class="cov8" title="1">{
                return nil, nil, nil, err
        }</span>
        <span class="cov8" title="1">e, s, err := z.Children(path)
        if err != nil </span><span class="cov8" title="1">{
                return e, s, nil, err
        }</span>
        <span class="cov8" title="1">return e, s, z.patchWatch(path), err</span>
}

func (z *MemoryZkServer) delete(path string, version int32) error <span class="cov8" title="1">{
        z.rootLock.Lock()
        defer z.rootLock.Unlock()
        if err := z.check("delete"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">path = fixPath(path)
        at, parent := z.node(path)
        if at == nil </span><span class="cov8" title="1">{
                return zk.ErrNoNode
        }</span>
        <span class="cov8" title="1">if version != at.stat.Version &amp;&amp; version != -1 </span><span class="cov8" title="1">{
                return zk.ErrBadVersion
        }</span>
        <span class="cov8" title="1">if len(at.children) != 0 </span><span class="cov8" title="1">{
                return zk.ErrNotEmpty
        }</span>

        <span class="cov8" title="1">delete(at.parent.children, at.name)
        z.addEvent(zk.Event{
                Type:  zk.EventNodeDeleted,
                State: zk.StateConnected,
                Path:  path,
                Err:   nil,
        })

        z.addEvent(zk.Event{
                Type:  zk.EventNodeChildrenChanged,
                State: zk.StateConnected,
                Path:  parent.path(),
                Err:   nil,
        })

        return nil</span>
}

// Delete a Zk node
func (z *ZkConn) Delete(path string, version int32) error <span class="cov8" title="1">{
        z.methodCallLock.Lock()
        defer z.methodCallLock.Unlock()
        if err := z.check("delete"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return z.connectedTo.delete(path, version)</span>
}

func (z *MemoryZkServer) create(path string, data []byte, flags int32, acl []zk.ACL) (string, error) <span class="cov8" title="1">{
        z.rootLock.Lock()
        defer z.rootLock.Unlock()
        path = fixPath(path)
        if err := z.check("create"); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">at, parent := z.node(path)
        if at != nil </span><span class="cov8" title="1">{
                return "", zk.ErrNodeExists
        }</span>
        <span class="cov8" title="1">if parent == nil </span><span class="cov8" title="1">{
                return "", zk.ErrNoNode
        }</span>
        <span class="cov8" title="1">name := path[len(parent.path())+1:]
        n := &amp;zkNode{
                data:     data,
                children: make(map[string]*zkNode),
                name:     name,
                parent:   parent,
                stat:     &amp;zk.Stat{},
        }
        parent.children[n.name] = n
        z.addEvent(zk.Event{
                Type:  zk.EventNodeCreated,
                State: zk.StateConnected,
                Path:  path,
                Err:   nil,
        })

        z.addEvent(zk.Event{
                Type:  zk.EventNodeChildrenChanged,
                State: zk.StateConnected,
                Path:  parent.path(),
                Err:   nil,
        })
        return n.path(), nil</span>
}

// Create a Zk node
func (z *ZkConn) Create(path string, data []byte, flags int32, acl []zk.ACL) (string, error) <span class="cov8" title="1">{
        z.methodCallLock.Lock()
        defer z.methodCallLock.Unlock()
        if err := z.check("create"); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return z.connectedTo.create(path, data, flags, acl)</span>
}

func (z *MemoryZkServer) set(path string, data []byte, version int32) (*zk.Stat, error) <span class="cov8" title="1">{
        z.rootLock.Lock()
        defer z.rootLock.Unlock()
        path = fixPath(path)
        at, _ := z.node(path)
        if at == nil </span><span class="cov8" title="1">{
                return nil, zk.ErrNoNode
        }</span>
        <span class="cov8" title="1">if version != at.stat.Version </span><span class="cov8" title="1">{
                return nil, zk.ErrBadVersion
        }</span>
        <span class="cov8" title="1">at.data = data
        at.stat.Version++
        z.addEvent(zk.Event{
                Type:  zk.EventNodeDataChanged,
                State: zk.StateConnected,
                Path:  path,
                Err:   nil,
        })
        return at.stat, nil</span>
}

// Set the data of a zk node
func (z *ZkConn) Set(path string, data []byte, version int32) (*zk.Stat, error) <span class="cov8" title="1">{
        z.methodCallLock.Lock()
        defer z.methodCallLock.Unlock()
        return z.connectedTo.set(path, data, version)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
