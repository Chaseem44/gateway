
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/signalfx/golib/distconf/bool.go (100.0%)</option>
				
				<option value="file1">github.com/signalfx/golib/distconf/cmd.go (100.0%)</option>
				
				<option value="file2">github.com/signalfx/golib/distconf/distconf.go (100.0%)</option>
				
				<option value="file3">github.com/signalfx/golib/distconf/duration.go (100.0%)</option>
				
				<option value="file4">github.com/signalfx/golib/distconf/env.go (100.0%)</option>
				
				<option value="file5">github.com/signalfx/golib/distconf/float.go (100.0%)</option>
				
				<option value="file6">github.com/signalfx/golib/distconf/ini.go (100.0%)</option>
				
				<option value="file7">github.com/signalfx/golib/distconf/int.go (100.0%)</option>
				
				<option value="file8">github.com/signalfx/golib/distconf/loading.go (100.0%)</option>
				
				<option value="file9">github.com/signalfx/golib/distconf/mem.go (100.0%)</option>
				
				<option value="file10">github.com/signalfx/golib/distconf/str.go (100.0%)</option>
				
				<option value="file11">github.com/signalfx/golib/distconf/zk.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package distconf

import (
        "strconv"
        "sync"
        "sync/atomic"
)

// BoolWatch is executed if registered on a Bool variable any time the Bool contents change
type BoolWatch func(str *Bool, oldValue bool)

type boolConf struct {
        Bool
        defaultVal int32
}

// Bool is a Boolean type config inside a Config.  It uses strconv.ParseBool to parse the conf
// contents as either true for false
type Bool struct {
        watches []BoolWatch

        // Lock on watches so updates are atomic
        mutex      sync.Mutex
        currentVal int32
}

// Update the contents of Bool to the new value
func (s *boolConf) Update(newValue []byte) error <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        oldValue := s.Get()
        if newValue == nil </span><span class="cov8" title="1">{
                atomic.StoreInt32(&amp;s.currentVal, s.defaultVal)
        }</span><span class="cov8" title="1"> else {
                newValueStr := string(newValue)
                if parsedBool, err := strconv.ParseBool(newValueStr); err != nil </span><span class="cov8" title="1">{
                        atomic.StoreInt32(&amp;s.currentVal, s.defaultVal)
                }</span><span class="cov8" title="1"> else if parsedBool </span><span class="cov8" title="1">{
                        atomic.StoreInt32(&amp;s.currentVal, 1)
                }</span><span class="cov8" title="1"> else {
                        atomic.StoreInt32(&amp;s.currentVal, 0)
                }</span>
        }
        <span class="cov8" title="1">if oldValue != s.Get() </span><span class="cov8" title="1">{
                for _, w := range s.watches </span><span class="cov8" title="1">{
                        w(&amp;s.Bool, oldValue)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Get the boolean in this config variable
func (s *Bool) Get() bool <span class="cov8" title="1">{
        return atomic.LoadInt32(&amp;s.currentVal) != 0
}</span>

// Watch adds a watch for changes to this structure
func (s *Bool) Watch(watch BoolWatch) <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        s.watches = append(s.watches, watch)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package distconf

import (
        "os"
        "strings"
)

type cmdDisco struct {
        noopCloser
        prefix string
        source []string
}

func (p *cmdDisco) Get(key string) ([]byte, error) <span class="cov8" title="1">{
        argPrefix := p.prefix + key + "="
        for _, arg := range p.source </span><span class="cov8" title="1">{
                if !strings.HasPrefix(arg, argPrefix) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">argSuffix := arg[len(argPrefix):]
                return []byte(argSuffix), nil</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}

// Cmd creates a backing reader that reads config varaibles from command line parameters with a prefix
func Cmd(prefix string) Reader <span class="cov8" title="1">{
        return &amp;cmdDisco{
                prefix: prefix,
                source: os.Args,
        }
}</span>

// CmdLoader is a loading helper for command line config variables
func CmdLoader(prefix string) BackingLoader <span class="cov8" title="1">{
        return BackingLoaderFunc(func() (Reader, error) </span><span class="cov8" title="1">{
                return Cmd(prefix), nil
        }</span>)
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package distconf

import (
        "sync"

        "time"

        "math"

        log "github.com/Sirupsen/logrus"
)

// Config gets configuration data from the first backing that has it
type Config struct {
        readers []Reader

        varsMutex      sync.Mutex
        registeredVars map[string]configVariable
}

type configVariable interface {
        Update(newValue []byte) error
}

type noopCloser struct {
}

func (n *noopCloser) Close() <span class="cov0" title="0">{
}</span>

// Int object that can be referenced to get integer values from a backing config
func (c *Config) Int(key string, defaultVal int64) *Int <span class="cov8" title="1">{
        s := &amp;intConf{
                defaultVal: defaultVal,
                Int: Int{
                        currentVal: defaultVal,
                },
        }
        // Note: in race conditions 's' may not be the thing actually returned
        ret, okCast := c.register(key, s).(*intConf)
        if !okCast </span><span class="cov8" title="1">{
                log.WithField("key", key).Error("Registering key with multiple types!  FIX ME!!!!")
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;ret.Int</span>
}

// Float object that can be referenced to get float values from a backing config
func (c *Config) Float(key string, defaultVal float64) *Float <span class="cov8" title="1">{
        s := &amp;floatConf{
                defaultVal: defaultVal,
                Float: Float{
                        currentVal: math.Float64bits(defaultVal),
                },
        }
        // Note: in race conditions 's' may not be the thing actually returned
        ret, okCast := c.register(key, s).(*floatConf)
        if !okCast </span><span class="cov8" title="1">{
                log.WithField("key", key).Error("Registering key with multiple types!  FIX ME!!!!")
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;ret.Float</span>
}

// Str object that can be referenced to get string values from a backing config
func (c *Config) Str(key string, defaultVal string) *Str <span class="cov8" title="1">{
        s := &amp;strConf{
                defaultVal: defaultVal,
        }
        s.currentVal.Store(defaultVal)
        // Note: in race conditions 's' may not be the thing actually returned
        ret, okCast := c.register(key, s).(*strConf)
        if !okCast </span><span class="cov8" title="1">{
                log.WithField("key", key).Error("Registering key with multiple types!  FIX ME!!!!")
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;ret.Str</span>
}

// Bool object that can be referenced to get boolean values from a backing config
func (c *Config) Bool(key string, defaultVal bool) *Bool <span class="cov8" title="1">{
        var defautlAsInt int32
        if defaultVal </span><span class="cov8" title="1">{
                defautlAsInt = 1
        }</span><span class="cov8" title="1"> else {
                defautlAsInt = 0
        }</span>

        <span class="cov8" title="1">s := &amp;boolConf{
                defaultVal: defautlAsInt,
                Bool: Bool{
                        currentVal: defautlAsInt,
                },
        }
        // Note: in race conditions 's' may not be the thing actually returned
        ret, okCast := c.register(key, s).(*boolConf)
        if !okCast </span><span class="cov8" title="1">{
                log.WithField("key", key).Error("Registering key with multiple types!  FIX ME!!!!")
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;ret.Bool</span>
}

// Duration returns a duration object that calls ParseDuration() on the given key
func (c *Config) Duration(key string, defaultVal time.Duration) *Duration <span class="cov8" title="1">{
        s := &amp;durationConf{
                defaultVal: defaultVal,
                Duration: Duration{
                        currentVal: defaultVal.Nanoseconds(),
                },
        }
        // Note: in race conditions 's' may not be the thing actually returned
        ret, okCast := c.register(key, s).(*durationConf)
        if !okCast </span><span class="cov8" title="1">{
                log.WithField("key", key).Error("Registering key with multiple types!  FIX ME!!!!")
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;ret.Duration</span>
}

// Close this config framework's readers.  Config variable results are undefined after this call.
func (c *Config) Close() <span class="cov8" title="1">{
        c.varsMutex.Lock()
        defer c.varsMutex.Unlock()
        for _, backing := range c.readers </span><span class="cov8" title="1">{
                backing.Close()
        }</span>
}

func (c *Config) register(key string, configVariable configVariable) configVariable <span class="cov8" title="1">{
        c.varsMutex.Lock()
        defer c.varsMutex.Unlock()
        existing, exists := c.registeredVars[key]
        if exists </span><span class="cov8" title="1">{
                // Don't log if everything else is the same?
                log.WithField("key", key).Warn("Possible race registering key")
                c.refresh(key, existing)
                return existing
        }</span>
        <span class="cov8" title="1">dynamicOnPath := c.refresh(key, configVariable)
        if dynamicOnPath </span><span class="cov8" title="1">{
                c.watch(key, configVariable)
        }</span>
        <span class="cov8" title="1">c.registeredVars[key] = configVariable
        return configVariable</span>
}

func (c *Config) refresh(key string, configVar configVariable) bool <span class="cov8" title="1">{
        dynamicReadersOnPath := false
        for _, backing := range c.readers </span><span class="cov8" title="1">{
                if !dynamicReadersOnPath </span><span class="cov8" title="1">{
                        _, ok := backing.(Dynamic)
                        if ok </span><span class="cov8" title="1">{
                                dynamicReadersOnPath = true
                        }</span>
                }

                <span class="cov8" title="1">v, e := backing.Get(key)
                if e != nil </span><span class="cov8" title="1">{
                        log.WithField("err", e).Warn("Unable to read from backing")
                        continue</span>
                }
                <span class="cov8" title="1">if v != nil </span><span class="cov8" title="1">{
                        e = configVar.Update(v)
                        if e != nil </span><span class="cov8" title="1">{
                                log.WithField("err", e).Error("Invalid config bytes for " + key)
                        }</span>
                        <span class="cov8" title="1">return dynamicReadersOnPath</span>
                }
        }

        <span class="cov8" title="1">e := configVar.Update(nil)
        if e != nil </span><span class="cov8" title="1">{
                log.WithField("err", e).Warn("Unable to set bytes to nil/clear")
        }</span>

        // If this is false, then the variable is fixed and can never change
        <span class="cov8" title="1">return dynamicReadersOnPath</span>
}

func (c *Config) watch(key string, configVar configVariable) <span class="cov8" title="1">{
        for _, backing := range c.readers </span><span class="cov8" title="1">{
                d, ok := backing.(Dynamic)
                if ok </span><span class="cov8" title="1">{
                        err := d.Watch(key, c.onBackingChange)
                        if err != nil </span><span class="cov8" title="1">{
                                log.WithField("err", err).WithField("key", key).Warn("Unable to watch for config var")
                        }</span>
                }
        }
}

func (c *Config) onBackingChange(key string) <span class="cov8" title="1">{
        m, exists := c.registeredVars[key]
        if !exists </span><span class="cov8" title="1">{
                log.WithField("key", key).Warn("Backing callback on variable that doesn't exist")
                return
        }</span>
        <span class="cov8" title="1">c.refresh(key, m)</span>
}

// Reader can get a []byte value for a config key
type Reader interface {
        Get(key string) ([]byte, error)
        Close()
}

// Writer can modify Config properties
type Writer interface {
        Write(key string, value []byte) error
}

type backingCallbackFunction func(string)

// A Dynamic config can change what it thinks a value is over time.
type Dynamic interface {
        Watch(key string, callback backingCallbackFunction) error
}

// A ReaderWriter can both read and write configuration information
type ReaderWriter interface {
        Reader
        Writer
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package distconf

import (
        "sync"
        "sync/atomic"
        "time"

        log "github.com/Sirupsen/logrus"
)

// DurationWatch is executed if registered on a Duration variable any time the contents change
type DurationWatch func(duration *Duration, oldValue time.Duration)

type durationConf struct {
        Duration
        defaultVal time.Duration
}

// Duration is a duration type config inside a Config.
type Duration struct {
        watches []DurationWatch

        // Lock on watches so updates are atomic
        mutex      sync.Mutex
        currentVal int64
}

// Get the string in this config variable
func (s *Duration) Get() time.Duration <span class="cov8" title="1">{
        return time.Duration(atomic.LoadInt64(&amp;s.currentVal))
}</span>

// Update the contents of Duration to the new value
func (s *durationConf) Update(newValue []byte) error <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        oldValue := s.Get()
        if newValue == nil </span><span class="cov8" title="1">{
                atomic.StoreInt64(&amp;s.currentVal, int64(s.defaultVal))
        }</span><span class="cov8" title="1"> else {
                newValDuration, err := time.ParseDuration(string(newValue))
                if err != nil </span><span class="cov8" title="1">{
                        log.WithField("err", err).WithField("newValue", string(newValue)).Warn("Invalid duration string")
                        atomic.StoreInt64(&amp;s.currentVal, int64(s.defaultVal))
                }</span><span class="cov8" title="1"> else {
                        atomic.StoreInt64(&amp;s.currentVal, int64(newValDuration))
                }</span>
        }
        <span class="cov8" title="1">if oldValue != s.Get() </span><span class="cov8" title="1">{
                for _, w := range s.watches </span><span class="cov8" title="1">{
                        w(&amp;s.Duration, oldValue)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Watch adds a watch for changes to this structure
func (s *Duration) Watch(watch DurationWatch) <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        s.watches = append(s.watches, watch)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package distconf

import "os"

type envDisco struct {
        noopCloser
}

func (p *envDisco) Get(key string) ([]byte, error) <span class="cov8" title="1">{
        val := os.Getenv(key)
        if val == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return []byte(val), nil</span>
}

// Env creates a backing config reader that reads properties from environment variables
func Env() Reader <span class="cov8" title="1">{
        return &amp;envDisco{}
}</span>

// EnvLoader is a loading helper for Env{} config variables
func EnvLoader() BackingLoader <span class="cov8" title="1">{
        return BackingLoaderFunc(func() (Reader, error) </span><span class="cov8" title="1">{
                return Env(), nil
        }</span>)
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package distconf

import (
        "math"
        "strconv"
        "sync"
        "sync/atomic"
)

// FloatWatch is called on any changes to a register integer config variable
type FloatWatch func(float *Float, oldValue float64)

type floatConf struct {
        Float
        defaultVal float64
}

// Float is an float type config inside a Config.
type Float struct {
        mutex   sync.Mutex
        watches []FloatWatch
        // Lock on update() so watches are called correctly
        // store as uint64 and convert on way in and out for atomicity
        currentVal uint64
}

// Get the float in this config variable
func (c *Float) Get() float64 <span class="cov8" title="1">{
        return math.Float64frombits(atomic.LoadUint64(&amp;c.currentVal))
}</span>

// Update the content of this config variable to newValue.
func (c *floatConf) Update(newValue []byte) error <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()
        oldValue := c.Get()
        if newValue == nil </span><span class="cov8" title="1">{
                atomic.StoreUint64(&amp;c.currentVal, math.Float64bits(c.defaultVal))
        }</span><span class="cov8" title="1"> else {
                newValueFloat, err := strconv.ParseFloat(string(newValue), 64)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">atomic.StoreUint64(&amp;c.currentVal, math.Float64bits(newValueFloat))</span>
        }
        <span class="cov8" title="1">if oldValue != c.Get() </span><span class="cov8" title="1">{
                for _, w := range c.watches </span><span class="cov8" title="1">{
                        w(&amp;c.Float, oldValue)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Watch for changes to this variable.
func (c *Float) Watch(watch FloatWatch) <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()
        c.watches = append(c.watches, watch)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package distconf

import ini "github.com/vaughan0/go-ini"

type propertyFileDisco struct {
        noopCloser
        filename string
        file     ini.File
}

func (p *propertyFileDisco) Get(key string) ([]byte, error) <span class="cov8" title="1">{
        ret, ok := p.file.Get("", key)
        if !ok </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return []byte(ret), nil</span>
}

// Ini creates a backing config reader that reads properties from an Ini file
func Ini(filename string) (Reader, error) <span class="cov8" title="1">{
        file, err := ini.LoadFile(filename)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;propertyFileDisco{
                filename: filename,
                file:     file,
        }, nil</span>

}

// IniLoader is a helper for loading from Ini files
func IniLoader(filename string) BackingLoader <span class="cov8" title="1">{
        return BackingLoaderFunc(func() (Reader, error) </span><span class="cov8" title="1">{
                return Ini(filename)
        }</span>)
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package distconf

import (
        "strconv"
        "sync"
        "sync/atomic"
)

// IntWatch is called on any changes to a register integer config variable
type IntWatch func(str *Int, oldValue int64)

type intConf struct {
        Int
        defaultVal int64
}

// Int is an integer type config inside a Config.
type Int struct {
        mutex   sync.Mutex
        watches []IntWatch
        // Lock on update() so watches are called correctly
        currentVal int64
}

// Get the integer in this config variable
func (c *Int) Get() int64 <span class="cov8" title="1">{
        return atomic.LoadInt64(&amp;c.currentVal)
}</span>

// Update the content of this config variable to newValue.
func (c *intConf) Update(newValue []byte) error <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()
        oldValue := c.Get()
        if newValue == nil </span><span class="cov8" title="1">{
                atomic.StoreInt64(&amp;c.currentVal, c.defaultVal)
        }</span><span class="cov8" title="1"> else {
                newValueInt, err := strconv.ParseInt(string(newValue), 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">atomic.StoreInt64(&amp;c.currentVal, newValueInt)</span>
        }
        <span class="cov8" title="1">if oldValue != c.Get() </span><span class="cov8" title="1">{
                for _, w := range c.watches </span><span class="cov8" title="1">{
                        w(&amp;c.Int, oldValue)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Watch for changes to this variable.
func (c *Int) Watch(watch IntWatch) <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()
        c.watches = append(c.watches, watch)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package distconf

import log "github.com/Sirupsen/logrus"

// A BackingLoader should run a single time and get a Reader for Config
type BackingLoader interface {
        Get() (Reader, error)
}

// BackingLoaderFunc can wrap a function to turn it into a BackingLoader
type BackingLoaderFunc func() (Reader, error)

// Get a Reader for Config, or an error if the Reader cannot be loaded
func (f BackingLoaderFunc) Get() (Reader, error) <span class="cov8" title="1">{
        return f()
}</span>

// FromLoaders creates a Config from an array of loaders, only using loaders that don't load with
// error
func FromLoaders(loaders []BackingLoader) *Config <span class="cov8" title="1">{
        readers := make([]Reader, 0, len(loaders))
        for _, l := range loaders </span><span class="cov8" title="1">{
                r, err := l.Get()
                if err != nil </span><span class="cov8" title="1">{
                        log.WithField("err", err).Warn("Unable to load reader")
                        continue</span>
                }
                <span class="cov8" title="1">readers = append(readers, r)</span>
        }
        <span class="cov8" title="1">return FromReaders(readers)</span>
}

// FromReaders creates a Config from the list of config values readers
func FromReaders(readers []Reader) *Config <span class="cov8" title="1">{
        return &amp;Config{
                readers:        readers,
                registeredVars: make(map[string]configVariable),
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package distconf

type memConfig struct {
        vals    map[string][]byte
        watches map[string][]backingCallbackFunction
}

func (m *memConfig) Get(key string) ([]byte, error) <span class="cov8" title="1">{
        b, exists := m.vals[key]
        if !exists </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return b, nil</span>
}

func (m *memConfig) Write(key string, value []byte) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                delete(m.vals, key)
        }</span><span class="cov8" title="1"> else {
                m.vals[key] = value
        }</span>

        <span class="cov8" title="1">for _, calls := range m.watches[key] </span><span class="cov8" title="1">{
                calls(key)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *memConfig) Watch(key string, callback backingCallbackFunction) error <span class="cov8" title="1">{
        _, existing := m.watches[key]
        if !existing </span><span class="cov8" title="1">{
                m.watches[key] = []backingCallbackFunction{}
        }</span>
        <span class="cov8" title="1">m.watches[key] = append(m.watches[key], callback)
        return nil</span>
}

func (m *memConfig) Close() <span class="cov8" title="1">{
}</span>

// Mem creates a memory config
func Mem() ReaderWriter <span class="cov8" title="1">{
        return &amp;memConfig{
                vals:    make(map[string][]byte),
                watches: make(map[string][]backingCallbackFunction),
        }
}</span>

// MemLoader is a helper for loading a memory conf
func MemLoader() BackingLoader <span class="cov8" title="1">{
        return BackingLoaderFunc(func() (Reader, error) </span><span class="cov8" title="1">{
                return Mem(), nil
        }</span>)
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package distconf

import (
        "sync"
        "sync/atomic"
)

// StrWatch is executed if registered on a Str variable any time the Str contents change
type StrWatch func(str *Str, oldValue string)

type strConf struct {
        Str
        defaultVal string
}

// Str is a string type config inside a Config.
type Str struct {
        watches []StrWatch

        // Lock on watches so updates are atomic
        mutex      sync.Mutex
        currentVal atomic.Value
}

// Update the contents of Str to the new value
func (s *strConf) Update(newValue []byte) error <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        oldValue := s.currentVal.Load().(string)
        if newValue == nil </span><span class="cov8" title="1">{
                s.currentVal.Store(s.defaultVal)
        }</span><span class="cov8" title="1"> else {
                s.currentVal.Store(string(newValue))
        }</span>
        <span class="cov8" title="1">if oldValue != s.Get() </span><span class="cov8" title="1">{
                for _, w := range s.watches </span><span class="cov8" title="1">{
                        w(&amp;s.Str, oldValue)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Get the string in this config variable
func (s *Str) Get() string <span class="cov8" title="1">{
        return s.currentVal.Load().(string)
}</span>

// Watch adds a watch for changes to this structure
func (s *Str) Watch(watch StrWatch) <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        s.watches = append(s.watches, watch)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package distconf

import (
        "fmt"

        "sync"

        "time"

        log "github.com/Sirupsen/logrus"
        "github.com/samuel/go-zookeeper/zk"
)

// ZkConn does zookeeper connections
type ZkConn interface {
        Exists(path string) (bool, *zk.Stat, error)
        Get(path string) ([]byte, *zk.Stat, error)
        GetW(path string) ([]byte, *zk.Stat, &lt;-chan zk.Event, error)
        Create(path string, data []byte, flags int32, acl []zk.ACL) (string, error)
        Set(path string, data []byte, version int32) (*zk.Stat, error)
        ExistsW(path string) (bool, *zk.Stat, &lt;-chan zk.Event, error)
        ChildrenW(path string) ([]string, *zk.Stat, &lt;-chan zk.Event, error)
        Delete(path string, version int32) error
        Close()
}

// ZkConnector creates zk connections for distconf
type ZkConnector interface {
        Connect() (ZkConn, &lt;-chan zk.Event, error)
}

// ZkConnectorFunc wraps a dumb function to help you get a ZkConnector
type ZkConnectorFunc func() (ZkConn, &lt;-chan zk.Event, error)

// Connect to Zk by calling itself()
func (z ZkConnectorFunc) Connect() (ZkConn, &lt;-chan zk.Event, error) <span class="cov8" title="1">{
        return z()
}</span>

type zkConfig struct {
        conn       ZkConn
        eventChan  &lt;-chan zk.Event
        shouldQuit chan struct{}
        servers    []string

        callbackLock      sync.Mutex
        callbacks         map[string][]backingCallbackFunction
        refreshRetryDelay time.Duration
}

func (back *zkConfig) configPath(key string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s", key)
}</span>

// Get returns the config value from zookeeper
func (back *zkConfig) Get(key string) ([]byte, error) <span class="cov8" title="1">{
        pathToFetch := back.configPath(key)
        bytes, _, _, err := back.conn.GetW(pathToFetch)
        if err != nil </span><span class="cov8" title="1">{
                if err == zk.ErrNoNode </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">return bytes, nil</span>
}

func (back *zkConfig) Write(key string, value []byte) error <span class="cov8" title="1">{
        log.WithField("key", key).Info("Write")
        path := back.configPath(key)
        exists, stat, err := back.conn.Exists(path)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                if value == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">_, err := back.conn.Create(path, value, 0, zk.WorldACL(zk.PermAll))
                return err</span>
        }
        <span class="cov8" title="1">if value == nil </span><span class="cov8" title="1">{
                err = back.conn.Delete(path, stat.Version)
        }</span><span class="cov8" title="1"> else {
                stat, err = back.conn.Set(path, value, stat.Version)
        }</span>

        <span class="cov8" title="1">return err</span>
}

func (back *zkConfig) Watch(key string, callback backingCallbackFunction) error <span class="cov8" title="1">{
        log.WithField("key", key).Debug("Watch")
        path := back.configPath(key)
        _, _, _, err := back.conn.ExistsW(path)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // use the connection's global event chan for callbacks
        <span class="cov8" title="1">back.callbackLock.Lock()
        defer back.callbackLock.Unlock()
        back.callbacks[path] = append(back.callbacks[path], callback)

        return nil</span>
}

func (back *zkConfig) Close() <span class="cov8" title="1">{
        close(back.shouldQuit)
        back.conn.Close()
}</span>

func (back *zkConfig) logInfoState(e zk.Event) bool <span class="cov8" title="1">{
        if e.State == zk.StateDisconnected </span><span class="cov8" title="1">{
                log.WithField("event", e).Info("Disconnected from zookeeper.  Will attempt to remake connection.")
                return true
        }</span>
        <span class="cov8" title="1">if e.State == zk.StateConnecting </span><span class="cov8" title="1">{
                log.WithField("event", e).Info("Server is now attempting to reconnect.")
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (back *zkConfig) drainEventChan() <span class="cov8" title="1">{
        defer log.Info("Quitting ZK distconf event loop")
        for </span><span class="cov8" title="1">{
                log.Info("Blocking with event")
                select </span>{
                <span class="cov8" title="1">case e := &lt;-back.eventChan:
                        log.WithField("event", e).Info("Event seen")
                        back.logInfoState(e)
                        if e.State == zk.StateHasSession </span><span class="cov8" title="1">{
                                log.WithField("event", e).Info("Server now has a session.")
                                back.refreshWatches()
                                continue</span>
                        }
                        <span class="cov8" title="1">if e.Path == "" </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if len(e.Path) &gt; 0 &amp;&amp; e.Path[0] == '/' </span><span class="cov8" title="1">{
                                e.Path = e.Path[1:]
                        }</span>
                        <span class="cov8" title="1">{
                                back.callbackLock.Lock()
                                log.WithField("event", e).WithField("len()", len(back.callbacks)).Info("Change state")
                                for _, c := range back.callbacks[e.Path] </span><span class="cov8" title="1">{
                                        c(e.Path)
                                }</span>
                                <span class="cov8" title="1">back.callbackLock.Unlock()</span>
                        }
                        <span class="cov8" title="1">log.WithField("path", e.Path).Info("reregistering watch")

                        // Note: return value currently ignored.  Not sure what to do about it
                        back.reregisterWatch(e.Path)
                        log.WithField("path", e.Path).Info("reregistering watch finished")</span>
                <span class="cov8" title="1">case &lt;-back.shouldQuit:
                        return</span>
                }
        }
}

func (back *zkConfig) refreshWatches() <span class="cov8" title="1">{
        back.callbackLock.Lock()
        defer back.callbackLock.Unlock()
        for path, callbacks := range back.callbacks </span><span class="cov8" title="1">{
                for _, c := range callbacks </span><span class="cov8" title="1">{
                        c(path)
                }</span>
                <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                        err := back.reregisterWatch(path)
                        if err == nil </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">log.Warnf("Error reregistering watch: %s  Will sleep and try again", err)
                        time.Sleep(back.refreshRetryDelay)</span>
                }
        }
}

func (back *zkConfig) setRefreshDelay(refreshDelay time.Duration) <span class="cov8" title="1">{
        back.callbackLock.Lock()
        defer back.callbackLock.Unlock()
        back.refreshRetryDelay = refreshDelay
}</span>

func (back *zkConfig) reregisterWatch(path string) error <span class="cov8" title="1">{
        log.Infof("Reregistering watch for %s", path)
        _, _, _, err := back.conn.ExistsW(path)
        if err != nil </span><span class="cov8" title="1">{
                log.WithField("err", err).Info("Unable to reregister watch")
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Zk creates a zookeeper readable backing
func Zk(zkConnector ZkConnector) (ReaderWriter, error) <span class="cov8" title="1">{
        ret := &amp;zkConfig{
                shouldQuit:        make(chan struct{}),
                callbacks:         make(map[string][]backingCallbackFunction),
                refreshRetryDelay: time.Millisecond * 500,
        }
        var err error
        ret.conn, ret.eventChan, err = zkConnector.Connect()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">go ret.drainEventChan()
        return ret, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
